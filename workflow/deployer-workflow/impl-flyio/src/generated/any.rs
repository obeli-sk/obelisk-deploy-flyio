// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!
// Options used:
#[allow(dead_code, clippy::all)]
pub mod obelisk_flyio {
  pub mod activity_fly_http {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod regions {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum Region {
        /// Amsterdam, Netherlands
        Ams,
        /// Stockholm, Sweden
        Arn,
        /// Atlanta, Georgia (US)
        Atl,
        /// Bogotá, Colombia
        Bog,
        /// Mumbai, India
        Bom,
        /// Boston, Massachusetts (US)
        Bos,
        /// Paris, France
        Cdg,
        /// Denver, Colorado (US)
        Den,
        /// Dallas, Texas (US)
        Dfw,
        /// Secaucus, NJ (US)
        Ewr,
        /// Ezeiza, Argentina
        Eze,
        /// Frankfurt, Germany
        Fra,
        /// Guadalajara, Mexico
        Gdl,
        /// Rio de Janeiro, Brazil
        Gig,
        /// Sao Paulo, Brazil
        Gru,
        /// Hong Kong, Hong Kong
        Hkg,
        /// Ashburn, Virginia (US)
        Iad,
        /// Johannesburg, South Africa
        Jnb,
        /// Los Angeles, California (US)
        Lax,
        /// London, United Kingdom
        Lhr,
        /// Madrid, Spain
        Mad,
        /// Miami, Florida (US)
        Mia,
        /// Tokyo, Japan
        Nrt,
        /// Chicago, Illinois (US)
        Ord,
        /// Bucharest, Romania
        Otp,
        /// Phoenix, Arizona (US)
        Phx,
        /// Querétaro, Mexico
        Qro,
        /// Santiago, Chile
        Scl,
        /// Seattle, Washington (US)
        Sea,
        /// Singapore, Singapore
        Sin,
        /// San Jose, California (US)
        Sjc,
        /// Sydney, Australia
        Syd,
        /// Warsaw, Poland
        Waw,
        /// Montreal, Canada
        Yul,
        /// Toronto, Canada
        Yyz,
      }
      impl ::core::fmt::Debug for Region {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Region::Ams => {
              f.debug_tuple("Region::Ams").finish()
            }
            Region::Arn => {
              f.debug_tuple("Region::Arn").finish()
            }
            Region::Atl => {
              f.debug_tuple("Region::Atl").finish()
            }
            Region::Bog => {
              f.debug_tuple("Region::Bog").finish()
            }
            Region::Bom => {
              f.debug_tuple("Region::Bom").finish()
            }
            Region::Bos => {
              f.debug_tuple("Region::Bos").finish()
            }
            Region::Cdg => {
              f.debug_tuple("Region::Cdg").finish()
            }
            Region::Den => {
              f.debug_tuple("Region::Den").finish()
            }
            Region::Dfw => {
              f.debug_tuple("Region::Dfw").finish()
            }
            Region::Ewr => {
              f.debug_tuple("Region::Ewr").finish()
            }
            Region::Eze => {
              f.debug_tuple("Region::Eze").finish()
            }
            Region::Fra => {
              f.debug_tuple("Region::Fra").finish()
            }
            Region::Gdl => {
              f.debug_tuple("Region::Gdl").finish()
            }
            Region::Gig => {
              f.debug_tuple("Region::Gig").finish()
            }
            Region::Gru => {
              f.debug_tuple("Region::Gru").finish()
            }
            Region::Hkg => {
              f.debug_tuple("Region::Hkg").finish()
            }
            Region::Iad => {
              f.debug_tuple("Region::Iad").finish()
            }
            Region::Jnb => {
              f.debug_tuple("Region::Jnb").finish()
            }
            Region::Lax => {
              f.debug_tuple("Region::Lax").finish()
            }
            Region::Lhr => {
              f.debug_tuple("Region::Lhr").finish()
            }
            Region::Mad => {
              f.debug_tuple("Region::Mad").finish()
            }
            Region::Mia => {
              f.debug_tuple("Region::Mia").finish()
            }
            Region::Nrt => {
              f.debug_tuple("Region::Nrt").finish()
            }
            Region::Ord => {
              f.debug_tuple("Region::Ord").finish()
            }
            Region::Otp => {
              f.debug_tuple("Region::Otp").finish()
            }
            Region::Phx => {
              f.debug_tuple("Region::Phx").finish()
            }
            Region::Qro => {
              f.debug_tuple("Region::Qro").finish()
            }
            Region::Scl => {
              f.debug_tuple("Region::Scl").finish()
            }
            Region::Sea => {
              f.debug_tuple("Region::Sea").finish()
            }
            Region::Sin => {
              f.debug_tuple("Region::Sin").finish()
            }
            Region::Sjc => {
              f.debug_tuple("Region::Sjc").finish()
            }
            Region::Syd => {
              f.debug_tuple("Region::Syd").finish()
            }
            Region::Waw => {
              f.debug_tuple("Region::Waw").finish()
            }
            Region::Yul => {
              f.debug_tuple("Region::Yul").finish()
            }
            Region::Yyz => {
              f.debug_tuple("Region::Yyz").finish()
            }
          }
        }
      }

      impl Region{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> Region{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => Region::Ams,
            1 => Region::Arn,
            2 => Region::Atl,
            3 => Region::Bog,
            4 => Region::Bom,
            5 => Region::Bos,
            6 => Region::Cdg,
            7 => Region::Den,
            8 => Region::Dfw,
            9 => Region::Ewr,
            10 => Region::Eze,
            11 => Region::Fra,
            12 => Region::Gdl,
            13 => Region::Gig,
            14 => Region::Gru,
            15 => Region::Hkg,
            16 => Region::Iad,
            17 => Region::Jnb,
            18 => Region::Lax,
            19 => Region::Lhr,
            20 => Region::Mad,
            21 => Region::Mia,
            22 => Region::Nrt,
            23 => Region::Ord,
            24 => Region::Otp,
            25 => Region::Phx,
            26 => Region::Qro,
            27 => Region::Scl,
            28 => Region::Sea,
            29 => Region::Sin,
            30 => Region::Sjc,
            31 => Region::Syd,
            32 => Region::Waw,
            33 => Region::Yul,
            34 => Region::Yyz,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }


    }

    /// [Volumes API](https://docs.machines.dev/#tag/volumes)
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod volumes {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type Region = super::super::super::obelisk_flyio::activity_fly_http::regions::Region;
      pub type VolumeId = _rt::String;
      #[derive(Clone)]
      pub struct Volume {
        pub id: _rt::String,
        pub name: _rt::String,
        pub state: _rt::String,
        pub region: Region,
        pub size_gb: u32,
        pub encrypted: bool,
        pub attached_machine_id: Option<_rt::String>,
        pub host_status: _rt::String,
        pub created_at: _rt::String,
        pub blocks: u32,
        pub block_size: u32,
        pub blocks_free: u32,
        pub blocks_avail: u32,
        pub bytes_used: u32,
        pub bytes_total: u32,
      }
      impl ::core::fmt::Debug for Volume {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Volume").field("id", &self.id).field("name", &self.name).field("state", &self.state).field("region", &self.region).field("size-gb", &self.size_gb).field("encrypted", &self.encrypted).field("attached-machine-id", &self.attached_machine_id).field("host-status", &self.host_status).field("created-at", &self.created_at).field("blocks", &self.blocks).field("block-size", &self.block_size).field("blocks-free", &self.blocks_free).field("blocks-avail", &self.blocks_avail).field("bytes-used", &self.bytes_used).field("bytes-total", &self.bytes_total).finish()
        }
      }
      #[derive(Clone)]
      pub struct VolumeCreateRequest {
        pub name: _rt::String,
        pub size_gb: u32,
        pub region: Region,
        pub require_unique_zone: Option<bool>,
      }
      impl ::core::fmt::Debug for VolumeCreateRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("VolumeCreateRequest").field("name", &self.name).field("size-gb", &self.size_gb).field("region", &self.region).field("require-unique-zone", &self.require_unique_zone).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// List all the volumes in an app.
      #[allow(async_fn_in_trait)]
      pub fn list(app_name: &str,) -> Result<_rt::Vec::<Volume>,_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = app_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/volumes@1.0.0-beta")]
          unsafe extern "C" {
            #[link_name = "list"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result38 = match l3 {
            0 => {
              let e = {
                let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base34 = l4;
                let len34 = l5;
                let mut result34 = _rt::Vec::with_capacity(len34);
                for i in 0..len34 {
                  let base = base34.add(i * (32+14*::core::mem::size_of::<*const u8>()));
                  let e34 = {
                    let l6 = *base.add(0).cast::<*mut u8>();
                    let l7 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let l9 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l10 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len11 = l10;
                    let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);
                    let l12 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l13 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len14 = l13;
                    let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
                    let l15 = i32::from(*base.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l16 = *base.add(4+6*::core::mem::size_of::<*const u8>()).cast::<i32>();
                    let l17 = i32::from(*base.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l18 = i32::from(*base.add(8+7*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l22 = *base.add(8+10*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l23 = *base.add(8+11*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len24 = l23;
                    let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);
                    let l25 = *base.add(8+12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l26 = *base.add(8+13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len27 = l26;
                    let bytes27 = _rt::Vec::from_raw_parts(l25.cast(), len27, len27);
                    let l28 = *base.add(8+14*::core::mem::size_of::<*const u8>()).cast::<i32>();
                    let l29 = *base.add(12+14*::core::mem::size_of::<*const u8>()).cast::<i32>();
                    let l30 = *base.add(16+14*::core::mem::size_of::<*const u8>()).cast::<i32>();
                    let l31 = *base.add(20+14*::core::mem::size_of::<*const u8>()).cast::<i32>();
                    let l32 = *base.add(24+14*::core::mem::size_of::<*const u8>()).cast::<i32>();
                    let l33 = *base.add(28+14*::core::mem::size_of::<*const u8>()).cast::<i32>();

                    Volume{
                      id: _rt::string_lift(bytes8),
                      name: _rt::string_lift(bytes11),
                      state: _rt::string_lift(bytes14),
                      region: super::super::super::obelisk_flyio::activity_fly_http::regions::Region::_lift(l15 as u8),
                      size_gb: l16 as u32,
                      encrypted: _rt::bool_lift(l17 as u8),
                      attached_machine_id: match l18 {
                        0 => None,
                        1 => {
                          let e = {
                            let l19 = *base.add(8+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l20 = *base.add(8+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len21 = l20;
                            let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);

                            _rt::string_lift(bytes21)
                          };
                          Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      },
                      host_status: _rt::string_lift(bytes24),
                      created_at: _rt::string_lift(bytes27),
                      blocks: l28 as u32,
                      block_size: l29 as u32,
                      blocks_free: l30 as u32,
                      blocks_avail: l31 as u32,
                      bytes_used: l32 as u32,
                      bytes_total: l33 as u32,
                    }
                  };
                  result34.push(e34);
                }
                _rt::cabi_dealloc(base34, len34 * (32+14*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                result34
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l35 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l36 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len37 = l36;
                let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);

                _rt::string_lift(bytes37)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result38
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Create a volume.
      #[allow(async_fn_in_trait)]
      pub fn create(app_name: &str,request: &VolumeCreateRequest,) -> Result<Volume,_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32+15*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32+15*::core::mem::size_of::<*const u8>()]);
          let vec0 = app_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let VolumeCreateRequest{ name:name1, size_gb:size_gb1, region:region1, require_unique_zone:require_unique_zone1, } = request;
          let vec2 = name1;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          let (result3_0,result3_1,) = match require_unique_zone1 {
            Some(e) => (1i32, match e { true => 1, false => 0 }),
            None => {
              (0i32, 0i32)
            },
          };let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/volumes@1.0.0-beta")]
          unsafe extern "C" {
            #[link_name = "create"]
            fn wit_import5(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import5(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
          wit_import5(ptr0.cast_mut(), len0, ptr2.cast_mut(), len2, _rt::as_i32(size_gb1), region1.clone() as i32, result3_0, result3_1, ptr4);
          let l6 = i32::from(*ptr4.add(0).cast::<u8>());
          let result38 = match l6 {
            0 => {
              let e = {
                let l7 = *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l8 = *ptr4.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len9 = l8;
                let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                let l10 = *ptr4.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l11 = *ptr4.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len12 = l11;
                let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                let l13 = *ptr4.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l14 = *ptr4.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len15 = l14;
                let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);
                let l16 = i32::from(*ptr4.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l17 = *ptr4.add(4+7*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l18 = i32::from(*ptr4.add(8+7*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l19 = i32::from(*ptr4.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l23 = *ptr4.add(8+11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l24 = *ptr4.add(8+12*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len25 = l24;
                let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);
                let l26 = *ptr4.add(8+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l27 = *ptr4.add(8+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len28 = l27;
                let bytes28 = _rt::Vec::from_raw_parts(l26.cast(), len28, len28);
                let l29 = *ptr4.add(8+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l30 = *ptr4.add(12+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l31 = *ptr4.add(16+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l32 = *ptr4.add(20+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l33 = *ptr4.add(24+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l34 = *ptr4.add(28+15*::core::mem::size_of::<*const u8>()).cast::<i32>();

                Volume{
                  id: _rt::string_lift(bytes9),
                  name: _rt::string_lift(bytes12),
                  state: _rt::string_lift(bytes15),
                  region: super::super::super::obelisk_flyio::activity_fly_http::regions::Region::_lift(l16 as u8),
                  size_gb: l17 as u32,
                  encrypted: _rt::bool_lift(l18 as u8),
                  attached_machine_id: match l19 {
                    0 => None,
                    1 => {
                      let e = {
                        let l20 = *ptr4.add(8+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l21 = *ptr4.add(8+10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len22 = l21;
                        let bytes22 = _rt::Vec::from_raw_parts(l20.cast(), len22, len22);

                        _rt::string_lift(bytes22)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  host_status: _rt::string_lift(bytes25),
                  created_at: _rt::string_lift(bytes28),
                  blocks: l29 as u32,
                  block_size: l30 as u32,
                  blocks_free: l31 as u32,
                  blocks_avail: l32 as u32,
                  bytes_used: l33 as u32,
                  bytes_total: l34 as u32,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l35 = *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l36 = *ptr4.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len37 = l36;
                let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);

                _rt::string_lift(bytes37)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result38
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get a specific volume.
      #[allow(async_fn_in_trait)]
      pub fn get(app_name: &str,volume_id: &str,) -> Result<Volume,_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 32+15*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32+15*::core::mem::size_of::<*const u8>()]);
          let vec0 = app_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = volume_id;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/volumes@1.0.0-beta")]
          unsafe extern "C" {
            #[link_name = "get"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l4 = i32::from(*ptr2.add(0).cast::<u8>());
          let result36 = match l4 {
            0 => {
              let e = {
                let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                let l8 = *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l9 = *ptr2.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len10 = l9;
                let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
                let l11 = *ptr2.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l12 = *ptr2.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len13 = l12;
                let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);
                let l14 = i32::from(*ptr2.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l15 = *ptr2.add(4+7*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l16 = i32::from(*ptr2.add(8+7*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l17 = i32::from(*ptr2.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let l21 = *ptr2.add(8+11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l22 = *ptr2.add(8+12*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len23 = l22;
                let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);
                let l24 = *ptr2.add(8+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l25 = *ptr2.add(8+14*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len26 = l25;
                let bytes26 = _rt::Vec::from_raw_parts(l24.cast(), len26, len26);
                let l27 = *ptr2.add(8+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l28 = *ptr2.add(12+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l29 = *ptr2.add(16+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l30 = *ptr2.add(20+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l31 = *ptr2.add(24+15*::core::mem::size_of::<*const u8>()).cast::<i32>();
                let l32 = *ptr2.add(28+15*::core::mem::size_of::<*const u8>()).cast::<i32>();

                Volume{
                  id: _rt::string_lift(bytes7),
                  name: _rt::string_lift(bytes10),
                  state: _rt::string_lift(bytes13),
                  region: super::super::super::obelisk_flyio::activity_fly_http::regions::Region::_lift(l14 as u8),
                  size_gb: l15 as u32,
                  encrypted: _rt::bool_lift(l16 as u8),
                  attached_machine_id: match l17 {
                    0 => None,
                    1 => {
                      let e = {
                        let l18 = *ptr2.add(8+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l19 = *ptr2.add(8+10*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let len20 = l19;
                        let bytes20 = _rt::Vec::from_raw_parts(l18.cast(), len20, len20);

                        _rt::string_lift(bytes20)
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  },
                  host_status: _rt::string_lift(bytes23),
                  created_at: _rt::string_lift(bytes26),
                  blocks: l27 as u32,
                  block_size: l28 as u32,
                  blocks_free: l29 as u32,
                  blocks_avail: l30 as u32,
                  bytes_used: l31 as u32,
                  bytes_total: l32 as u32,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l33 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l34 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len35 = l34;
                let bytes35 = _rt::Vec::from_raw_parts(l33.cast(), len35, len35);

                _rt::string_lift(bytes35)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result36
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Extend a volume.
      #[allow(async_fn_in_trait)]
      pub fn extend(app_name: &str,volume_id: &str,new_size_gb: u32,) -> Result<(),_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = app_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = volume_id;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/volumes@1.0.0-beta")]
          unsafe extern "C" {
            #[link_name = "extend"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, _rt::as_i32(&new_size_gb), ptr2);
          let l4 = i32::from(*ptr2.add(0).cast::<u8>());
          let result8 = match l4 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result8
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Delete a volume permanently.
      #[allow(async_fn_in_trait)]
      pub fn delete(app_name: &str,volume_id: &str,) -> Result<(),_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = app_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = volume_id;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/volumes@1.0.0-beta")]
          unsafe extern "C" {
            #[link_name = "delete"]
            fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
          let l4 = i32::from(*ptr2.add(0).cast::<u8>());
          let result8 = match l4 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len7 = l6;
                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                _rt::string_lift(bytes7)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result8
        }
      }

    }

    /// [Machines API](https://docs.machines.dev/#tag/machines/get/apps/{app_name}/machines)
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod machines {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type Region = super::super::super::obelisk_flyio::activity_fly_http::regions::Region;
      pub type VolumeId = super::super::super::obelisk_flyio::activity_fly_http::volumes::VolumeId;
      pub type MachineId = _rt::String;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum MachineState {
        Created,
        Starting,
        Started,
        Stopping,
        Stopped,
        Suspending,
        Suspended,
        Replacing,
        Replaced,
        Destroying,
        Destroyed,
      }
      impl ::core::fmt::Debug for MachineState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            MachineState::Created => {
              f.debug_tuple("MachineState::Created").finish()
            }
            MachineState::Starting => {
              f.debug_tuple("MachineState::Starting").finish()
            }
            MachineState::Started => {
              f.debug_tuple("MachineState::Started").finish()
            }
            MachineState::Stopping => {
              f.debug_tuple("MachineState::Stopping").finish()
            }
            MachineState::Stopped => {
              f.debug_tuple("MachineState::Stopped").finish()
            }
            MachineState::Suspending => {
              f.debug_tuple("MachineState::Suspending").finish()
            }
            MachineState::Suspended => {
              f.debug_tuple("MachineState::Suspended").finish()
            }
            MachineState::Replacing => {
              f.debug_tuple("MachineState::Replacing").finish()
            }
            MachineState::Replaced => {
              f.debug_tuple("MachineState::Replaced").finish()
            }
            MachineState::Destroying => {
              f.debug_tuple("MachineState::Destroying").finish()
            }
            MachineState::Destroyed => {
              f.debug_tuple("MachineState::Destroyed").finish()
            }
          }
        }
      }

      impl MachineState{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> MachineState{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => MachineState::Created,
            1 => MachineState::Starting,
            2 => MachineState::Started,
            3 => MachineState::Stopping,
            4 => MachineState::Stopped,
            5 => MachineState::Suspending,
            6 => MachineState::Suspended,
            7 => MachineState::Replacing,
            8 => MachineState::Replaced,
            9 => MachineState::Destroying,
            10 => MachineState::Destroyed,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum HostStatus {
        Ok,
        Unknown,
        Unreachable,
      }
      impl ::core::fmt::Debug for HostStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            HostStatus::Ok => {
              f.debug_tuple("HostStatus::Ok").finish()
            }
            HostStatus::Unknown => {
              f.debug_tuple("HostStatus::Unknown").finish()
            }
            HostStatus::Unreachable => {
              f.debug_tuple("HostStatus::Unreachable").finish()
            }
          }
        }
      }

      impl HostStatus{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> HostStatus{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => HostStatus::Ok,
            1 => HostStatus::Unknown,
            2 => HostStatus::Unreachable,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[derive(Clone)]
      pub struct Mount {
        pub volume: VolumeId,
        pub path: _rt::String,
      }
      impl ::core::fmt::Debug for Mount {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Mount").field("volume", &self.volume).field("path", &self.path).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum CpuKind {
        Shared,
        Performance,
      }
      impl ::core::fmt::Debug for CpuKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CpuKind::Shared => {
              f.debug_tuple("CpuKind::Shared").finish()
            }
            CpuKind::Performance => {
              f.debug_tuple("CpuKind::Performance").finish()
            }
          }
        }
      }

      impl CpuKind{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> CpuKind{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => CpuKind::Shared,
            1 => CpuKind::Performance,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[derive(Clone)]
      pub struct GuestConfig {
        pub cpu_kind: Option<CpuKind>,
        pub cpus: Option<u64>,
        pub memory_mb: Option<u64>,
        pub kernel_args: Option<_rt::Vec::<_rt::String>>,
      }
      impl ::core::fmt::Debug for GuestConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GuestConfig").field("cpu-kind", &self.cpu_kind).field("cpus", &self.cpus).field("memory-mb", &self.memory_mb).field("kernel-args", &self.kernel_args).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum RestartPolicy {
        No,
        Always,
        OnFailure,
      }
      impl ::core::fmt::Debug for RestartPolicy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            RestartPolicy::No => {
              f.debug_tuple("RestartPolicy::No").finish()
            }
            RestartPolicy::Always => {
              f.debug_tuple("RestartPolicy::Always").finish()
            }
            RestartPolicy::OnFailure => {
              f.debug_tuple("RestartPolicy::OnFailure").finish()
            }
          }
        }
      }

      impl RestartPolicy{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> RestartPolicy{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => RestartPolicy::No,
            1 => RestartPolicy::Always,
            2 => RestartPolicy::OnFailure,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct MachineRestart {
        pub max_retries: Option<u32>,
        pub policy: RestartPolicy,
      }
      impl ::core::fmt::Debug for MachineRestart {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("MachineRestart").field("max-retries", &self.max_retries).field("policy", &self.policy).finish()
        }
      }
      #[derive(Clone)]
      pub struct InitConfig {
        pub cmd: Option<_rt::Vec::<_rt::String>>,
        pub entrypoint: Option<_rt::Vec::<_rt::String>>,
        pub exec: Option<_rt::Vec::<_rt::String>>,
        pub kernel_args: Option<_rt::Vec::<_rt::String>>,
        pub swap_size_mb: Option<u64>,
        pub tty: Option<bool>,
      }
      impl ::core::fmt::Debug for InitConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("InitConfig").field("cmd", &self.cmd).field("entrypoint", &self.entrypoint).field("exec", &self.exec).field("kernel-args", &self.kernel_args).field("swap-size-mb", &self.swap_size_mb).field("tty", &self.tty).finish()
        }
      }
      #[derive(Clone)]
      pub struct StopConfig {
        pub signal: Option<_rt::String>,
        pub timeout: Option<u64>,
      }
      impl ::core::fmt::Debug for StopConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("StopConfig").field("signal", &self.signal).field("timeout", &self.timeout).finish()
        }
      }
      #[derive(Clone)]
      pub struct ExecResponse {
        pub exit_code: Option<i32>,
        pub exit_signal: Option<i32>,
        pub stderr: Option<_rt::String>,
        pub stdout: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for ExecResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ExecResponse").field("exit-code", &self.exit_code).field("exit-signal", &self.exit_signal).field("stderr", &self.stderr).field("stdout", &self.stdout).finish()
        }
      }
      /// Protocol for a service
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum ServiceProtocol {
        Tcp,
        Udp,
      }
      impl ::core::fmt::Debug for ServiceProtocol {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ServiceProtocol::Tcp => {
              f.debug_tuple("ServiceProtocol::Tcp").finish()
            }
            ServiceProtocol::Udp => {
              f.debug_tuple("ServiceProtocol::Udp").finish()
            }
          }
        }
      }

      impl ServiceProtocol{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ServiceProtocol{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ServiceProtocol::Tcp,
            1 => ServiceProtocol::Udp,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Handlers for a port
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum PortHandler {
        Http,
        Tls,
        Pg,
      }
      impl ::core::fmt::Debug for PortHandler {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            PortHandler::Http => {
              f.debug_tuple("PortHandler::Http").finish()
            }
            PortHandler::Tls => {
              f.debug_tuple("PortHandler::Tls").finish()
            }
            PortHandler::Pg => {
              f.debug_tuple("PortHandler::Pg").finish()
            }
          }
        }
      }

      impl PortHandler{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> PortHandler{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => PortHandler::Http,
            1 => PortHandler::Tls,
            2 => PortHandler::Pg,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Configuration for an external port
      #[derive(Clone)]
      pub struct PortConfig {
        pub port: u16,
        pub handlers: _rt::Vec::<PortHandler>,
      }
      impl ::core::fmt::Debug for PortConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PortConfig").field("port", &self.port).field("handlers", &self.handlers).finish()
        }
      }
      /// Configuration for a single service (port forwarding rule)
      #[derive(Clone)]
      pub struct ServiceConfig {
        pub internal_port: u16,
        pub protocol: ServiceProtocol,
        pub ports: _rt::Vec::<PortConfig>,
      }
      impl ::core::fmt::Debug for ServiceConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ServiceConfig").field("internal-port", &self.internal_port).field("protocol", &self.protocol).field("ports", &self.ports).finish()
        }
      }
      #[derive(Clone)]
      pub struct MachineConfig {
        pub image: _rt::String,
        pub guest: Option<GuestConfig>,
        pub auto_destroy: Option<bool>,
        pub init: Option<InitConfig>,
        pub env: Option<_rt::Vec::<(_rt::String,_rt::String,)>>,
        pub restart: Option<MachineRestart>,
        pub stop_config: Option<StopConfig>,
        pub mounts: Option<_rt::Vec::<Mount>>,
        pub services: Option<_rt::Vec::<ServiceConfig>>,
      }
      impl ::core::fmt::Debug for MachineConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("MachineConfig").field("image", &self.image).field("guest", &self.guest).field("auto-destroy", &self.auto_destroy).field("init", &self.init).field("env", &self.env).field("restart", &self.restart).field("stop-config", &self.stop_config).field("mounts", &self.mounts).field("services", &self.services).finish()
        }
      }
      #[derive(Clone)]
      pub struct Machine {
        pub config: MachineConfig,
        pub created_at: _rt::String,
        pub updated_at: _rt::String,
        pub id: _rt::String,
        pub instance_id: _rt::String,
        pub name: _rt::String,
        pub state: _rt::String,
        pub region: Region,
        pub host_status: HostStatus,
      }
      impl ::core::fmt::Debug for Machine {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Machine").field("config", &self.config).field("created-at", &self.created_at).field("updated-at", &self.updated_at).field("id", &self.id).field("instance-id", &self.instance_id).field("name", &self.name).field("state", &self.state).field("region", &self.region).field("host-status", &self.host_status).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// List machines
      #[allow(async_fn_in_trait)]
      pub fn list(app_name: &str,) -> Result<_rt::Vec::<Machine>,_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let vec0 = app_name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
          unsafe extern "C" {
            #[link_name = "list"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result127 = match l3 {
            0 => {
              let e = {
                let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l5 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base123 = l4;
                let len123 = l5;
                let mut result123 = _rt::Vec::with_capacity(len123);
                for i in 0..len123 {
                  let base = base123.add(i * (160+38*::core::mem::size_of::<*const u8>()));
                  let e123 = {
                    let l6 = *base.add(0).cast::<*mut u8>();
                    let l7 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let l9 = i32::from(*base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l23 = i32::from(*base.add(56+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l25 = i32::from(*base.add(64+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l58 = i32::from(*base.add(96+16*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l68 = i32::from(*base.add(96+19*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l72 = i32::from(*base.add(120+18*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l79 = i32::from(*base.add(152+20*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l89 = i32::from(*base.add(152+23*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l103 = *base.add(152+26*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l104 = *base.add(152+27*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len105 = l104;
                    let bytes105 = _rt::Vec::from_raw_parts(l103.cast(), len105, len105);
                    let l106 = *base.add(152+28*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l107 = *base.add(152+29*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len108 = l107;
                    let bytes108 = _rt::Vec::from_raw_parts(l106.cast(), len108, len108);
                    let l109 = *base.add(152+30*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l110 = *base.add(152+31*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len111 = l110;
                    let bytes111 = _rt::Vec::from_raw_parts(l109.cast(), len111, len111);
                    let l112 = *base.add(152+32*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l113 = *base.add(152+33*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len114 = l113;
                    let bytes114 = _rt::Vec::from_raw_parts(l112.cast(), len114, len114);
                    let l115 = *base.add(152+34*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l116 = *base.add(152+35*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len117 = l116;
                    let bytes117 = _rt::Vec::from_raw_parts(l115.cast(), len117, len117);
                    let l118 = *base.add(152+36*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                    let l119 = *base.add(152+37*::core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len120 = l119;
                    let bytes120 = _rt::Vec::from_raw_parts(l118.cast(), len120, len120);
                    let l121 = i32::from(*base.add(152+38*::core::mem::size_of::<*const u8>()).cast::<u8>());
                    let l122 = i32::from(*base.add(153+38*::core::mem::size_of::<*const u8>()).cast::<u8>());

                    Machine{
                      config: MachineConfig{
                        image: _rt::string_lift(bytes8),
                        guest: match l9 {
                          0 => None,
                          1 => {
                            let e = {
                              let l10 = i32::from(*base.add(8+2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l12 = i32::from(*base.add(16+2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l14 = i32::from(*base.add(32+2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l16 = i32::from(*base.add(48+2*::core::mem::size_of::<*const u8>()).cast::<u8>());

                              GuestConfig{
                                cpu_kind: match l10 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l11 = i32::from(*base.add(9+2*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                      CpuKind::_lift(l11 as u8)
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                cpus: match l12 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l13 = *base.add(24+2*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                      l13 as u64
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                memory_mb: match l14 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l15 = *base.add(40+2*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                      l15 as u64
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                kernel_args: match l16 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l17 = *base.add(48+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l18 = *base.add(48+4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let base22 = l17;
                                      let len22 = l18;
                                      let mut result22 = _rt::Vec::with_capacity(len22);
                                      for i in 0..len22 {
                                        let base = base22.add(i * (2*::core::mem::size_of::<*const u8>()));
                                        let e22 = {
                                          let l19 = *base.add(0).cast::<*mut u8>();
                                          let l20 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let len21 = l20;
                                          let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);

                                          _rt::string_lift(bytes21)
                                        };
                                        result22.push(e22);
                                      }
                                      _rt::cabi_dealloc(base22, len22 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                      result22
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                              }
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        auto_destroy: match l23 {
                          0 => None,
                          1 => {
                            let e = {
                              let l24 = i32::from(*base.add(57+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                              _rt::bool_lift(l24 as u8)
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        init: match l25 {
                          0 => None,
                          1 => {
                            let e = {
                              let l26 = i32::from(*base.add(72+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l33 = i32::from(*base.add(72+7*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l40 = i32::from(*base.add(72+10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l47 = i32::from(*base.add(72+13*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l54 = i32::from(*base.add(72+16*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l56 = i32::from(*base.add(88+16*::core::mem::size_of::<*const u8>()).cast::<u8>());

                              InitConfig{
                                cmd: match l26 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l27 = *base.add(72+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l28 = *base.add(72+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let base32 = l27;
                                      let len32 = l28;
                                      let mut result32 = _rt::Vec::with_capacity(len32);
                                      for i in 0..len32 {
                                        let base = base32.add(i * (2*::core::mem::size_of::<*const u8>()));
                                        let e32 = {
                                          let l29 = *base.add(0).cast::<*mut u8>();
                                          let l30 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let len31 = l30;
                                          let bytes31 = _rt::Vec::from_raw_parts(l29.cast(), len31, len31);

                                          _rt::string_lift(bytes31)
                                        };
                                        result32.push(e32);
                                      }
                                      _rt::cabi_dealloc(base32, len32 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                      result32
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                entrypoint: match l33 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l34 = *base.add(72+8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l35 = *base.add(72+9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let base39 = l34;
                                      let len39 = l35;
                                      let mut result39 = _rt::Vec::with_capacity(len39);
                                      for i in 0..len39 {
                                        let base = base39.add(i * (2*::core::mem::size_of::<*const u8>()));
                                        let e39 = {
                                          let l36 = *base.add(0).cast::<*mut u8>();
                                          let l37 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let len38 = l37;
                                          let bytes38 = _rt::Vec::from_raw_parts(l36.cast(), len38, len38);

                                          _rt::string_lift(bytes38)
                                        };
                                        result39.push(e39);
                                      }
                                      _rt::cabi_dealloc(base39, len39 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                      result39
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                exec: match l40 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l41 = *base.add(72+11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l42 = *base.add(72+12*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let base46 = l41;
                                      let len46 = l42;
                                      let mut result46 = _rt::Vec::with_capacity(len46);
                                      for i in 0..len46 {
                                        let base = base46.add(i * (2*::core::mem::size_of::<*const u8>()));
                                        let e46 = {
                                          let l43 = *base.add(0).cast::<*mut u8>();
                                          let l44 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let len45 = l44;
                                          let bytes45 = _rt::Vec::from_raw_parts(l43.cast(), len45, len45);

                                          _rt::string_lift(bytes45)
                                        };
                                        result46.push(e46);
                                      }
                                      _rt::cabi_dealloc(base46, len46 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                      result46
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                kernel_args: match l47 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l48 = *base.add(72+14*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l49 = *base.add(72+15*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let base53 = l48;
                                      let len53 = l49;
                                      let mut result53 = _rt::Vec::with_capacity(len53);
                                      for i in 0..len53 {
                                        let base = base53.add(i * (2*::core::mem::size_of::<*const u8>()));
                                        let e53 = {
                                          let l50 = *base.add(0).cast::<*mut u8>();
                                          let l51 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let len52 = l51;
                                          let bytes52 = _rt::Vec::from_raw_parts(l50.cast(), len52, len52);

                                          _rt::string_lift(bytes52)
                                        };
                                        result53.push(e53);
                                      }
                                      _rt::cabi_dealloc(base53, len53 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                      result53
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                swap_size_mb: match l54 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l55 = *base.add(80+16*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                      l55 as u64
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                tty: match l56 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l57 = i32::from(*base.add(89+16*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                      _rt::bool_lift(l57 as u8)
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                              }
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        env: match l58 {
                          0 => None,
                          1 => {
                            let e = {
                              let l59 = *base.add(96+17*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l60 = *base.add(96+18*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let base67 = l59;
                              let len67 = l60;
                              let mut result67 = _rt::Vec::with_capacity(len67);
                              for i in 0..len67 {
                                let base = base67.add(i * (4*::core::mem::size_of::<*const u8>()));
                                let e67 = {
                                  let l61 = *base.add(0).cast::<*mut u8>();
                                  let l62 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len63 = l62;
                                  let bytes63 = _rt::Vec::from_raw_parts(l61.cast(), len63, len63);
                                  let l64 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l65 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len66 = l65;
                                  let bytes66 = _rt::Vec::from_raw_parts(l64.cast(), len66, len66);

                                  (_rt::string_lift(bytes63), _rt::string_lift(bytes66))
                                };
                                result67.push(e67);
                              }
                              _rt::cabi_dealloc(base67, len67 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                              result67
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        restart: match l68 {
                          0 => None,
                          1 => {
                            let e = {
                              let l69 = i32::from(*base.add(100+19*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l71 = i32::from(*base.add(108+19*::core::mem::size_of::<*const u8>()).cast::<u8>());

                              MachineRestart{
                                max_retries: match l69 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l70 = *base.add(104+19*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                      l70 as u32
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                policy: RestartPolicy::_lift(l71 as u8),
                              }
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        stop_config: match l72 {
                          0 => None,
                          1 => {
                            let e = {
                              let l73 = i32::from(*base.add(128+18*::core::mem::size_of::<*const u8>()).cast::<u8>());
                              let l77 = i32::from(*base.add(136+20*::core::mem::size_of::<*const u8>()).cast::<u8>());

                              StopConfig{
                                signal: match l73 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l74 = *base.add(128+19*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l75 = *base.add(128+20*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let len76 = l75;
                                      let bytes76 = _rt::Vec::from_raw_parts(l74.cast(), len76, len76);

                                      _rt::string_lift(bytes76)
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                                timeout: match l77 {
                                  0 => None,
                                  1 => {
                                    let e = {
                                      let l78 = *base.add(144+20*::core::mem::size_of::<*const u8>()).cast::<i64>();

                                      l78 as u64
                                    };
                                    Some(e)
                                  }
                                  _ => _rt::invalid_enum_discriminant(),
                                },
                              }
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        mounts: match l79 {
                          0 => None,
                          1 => {
                            let e = {
                              let l80 = *base.add(152+21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l81 = *base.add(152+22*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let base88 = l80;
                              let len88 = l81;
                              let mut result88 = _rt::Vec::with_capacity(len88);
                              for i in 0..len88 {
                                let base = base88.add(i * (4*::core::mem::size_of::<*const u8>()));
                                let e88 = {
                                  let l82 = *base.add(0).cast::<*mut u8>();
                                  let l83 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len84 = l83;
                                  let bytes84 = _rt::Vec::from_raw_parts(l82.cast(), len84, len84);
                                  let l85 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l86 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len87 = l86;
                                  let bytes87 = _rt::Vec::from_raw_parts(l85.cast(), len87, len87);

                                  Mount{
                                    volume: _rt::string_lift(bytes84),
                                    path: _rt::string_lift(bytes87),
                                  }
                                };
                                result88.push(e88);
                              }
                              _rt::cabi_dealloc(base88, len88 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                              result88
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        services: match l89 {
                          0 => None,
                          1 => {
                            let e = {
                              let l90 = *base.add(152+24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                              let l91 = *base.add(152+25*::core::mem::size_of::<*const u8>()).cast::<usize>();
                              let base102 = l90;
                              let len102 = l91;
                              let mut result102 = _rt::Vec::with_capacity(len102);
                              for i in 0..len102 {
                                let base = base102.add(i * (3*::core::mem::size_of::<*const u8>()));
                                let e102 = {
                                  let l92 = i32::from(*base.add(0).cast::<u16>());
                                  let l93 = i32::from(*base.add(2).cast::<u8>());
                                  let l94 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l95 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let base101 = l94;
                                  let len101 = l95;
                                  let mut result101 = _rt::Vec::with_capacity(len101);
                                  for i in 0..len101 {
                                    let base = base101.add(i * (3*::core::mem::size_of::<*const u8>()));
                                    let e101 = {
                                      let l96 = i32::from(*base.add(0).cast::<u16>());
                                      let l97 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l98 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let base100 = l97;
                                      let len100 = l98;
                                      let mut result100 = _rt::Vec::with_capacity(len100);
                                      for i in 0..len100 {
                                        let base = base100.add(i * 1);
                                        let e100 = {
                                          let l99 = i32::from(*base.add(0).cast::<u8>());

                                          PortHandler::_lift(l99 as u8)
                                        };
                                        result100.push(e100);
                                      }
                                      _rt::cabi_dealloc(base100, len100 * 1, 1);

                                      PortConfig{
                                        port: l96 as u16,
                                        handlers: result100,
                                      }
                                    };
                                    result101.push(e101);
                                  }
                                  _rt::cabi_dealloc(base101, len101 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                  ServiceConfig{
                                    internal_port: l92 as u16,
                                    protocol: ServiceProtocol::_lift(l93 as u8),
                                    ports: result101,
                                  }
                                };
                                result102.push(e102);
                              }
                              _rt::cabi_dealloc(base102, len102 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                              result102
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      },
                      created_at: _rt::string_lift(bytes105),
                      updated_at: _rt::string_lift(bytes108),
                      id: _rt::string_lift(bytes111),
                      instance_id: _rt::string_lift(bytes114),
                      name: _rt::string_lift(bytes117),
                      state: _rt::string_lift(bytes120),
                      region: super::super::super::obelisk_flyio::activity_fly_http::regions::Region::_lift(l121 as u8),
                      host_status: HostStatus::_lift(l122 as u8),
                    }
                  };
                  result123.push(e123);
                }
                _rt::cabi_dealloc(base123, len123 * (160+38*::core::mem::size_of::<*const u8>()), 8);

                result123
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l124 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l125 = *ptr1.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len126 = l125;
                let bytes126 = _rt::Vec::from_raw_parts(l124.cast(), len126, len126);

                _rt::string_lift(bytes126)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result127
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Create and start a machine under `app-name` with name `machine-name` and return its ID.
      /// If machine already exists, attributes of `machine-config` are not updated, just the machine ID is returned.
      #[allow(async_fn_in_trait)]
      pub fn create(app_name: &str,machine_name: &str,machine_config: &MachineConfig,region: Option<Region>,) -> Result<_rt::String,_rt::String>{
        unsafe {
          let mut cleanup_list = _rt::Vec::new();

          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 160+30*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 160+30*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = app_name;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
          *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
          let vec2 = machine_name;
          let ptr2 = vec2.as_ptr().cast::<u8>();
          let len2 = vec2.len();
          *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
          *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
          let MachineConfig{ image:image3, guest:guest3, auto_destroy:auto_destroy3, init:init3, env:env3, restart:restart3, stop_config:stop_config3, mounts:mounts3, services:services3, } = machine_config;
          let vec4 = image3;
          let ptr4 = vec4.as_ptr().cast::<u8>();
          let len4 = vec4.len();
          *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
          *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
          match guest3 {
            Some(e) => {
              *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
              let GuestConfig{ cpu_kind:cpu_kind5, cpus:cpus5, memory_mb:memory_mb5, kernel_args:kernel_args5, } = e;
              match cpu_kind5 {
                Some(e) => {
                  *ptr0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *ptr0.add(9+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                },
                None => {
                  {
                    *ptr0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match cpus5 {
                Some(e) => {
                  *ptr0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *ptr0.add(24+6*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                },
                None => {
                  {
                    *ptr0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match memory_mb5 {
                Some(e) => {
                  *ptr0.add(32+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  *ptr0.add(40+6*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                },
                None => {
                  {
                    *ptr0.add(32+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match kernel_args5 {
                Some(e) => {
                  *ptr0.add(48+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec7 = e;
                  let len7 = vec7.len();
                  let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                  let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);cleanup_list.extend(_cleanup7);
                  for (i, e) in vec7.into_iter().enumerate() {
                    let base = result7.add(i * (2*::core::mem::size_of::<*const u8>()));
                    {
                      let vec6 = e;
                      let ptr6 = vec6.as_ptr().cast::<u8>();
                      let len6 = vec6.len();
                      *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                      *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                    }
                  }
                  *ptr0.add(48+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                  *ptr0.add(48+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result7;
                },
                None => {
                  {
                    *ptr0.add(48+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };},
              None => {
                {
                  *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match auto_destroy3 {
              Some(e) => {
                *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                *ptr0.add(57+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
              },
              None => {
                {
                  *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match init3 {
              Some(e) => {
                *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let InitConfig{ cmd:cmd8, entrypoint:entrypoint8, exec:exec8, kernel_args:kernel_args8, swap_size_mb:swap_size_mb8, tty:tty8, } = e;
                match cmd8 {
                  Some(e) => {
                    *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec10 = e;
                    let len10 = vec10.len();
                    let layout10 = _rt::alloc::Layout::from_size_align(vec10.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                    let (result10, _cleanup10) = wit_bindgen::rt::Cleanup::new(layout10);cleanup_list.extend(_cleanup10);
                    for (i, e) in vec10.into_iter().enumerate() {
                      let base = result10.add(i * (2*::core::mem::size_of::<*const u8>()));
                      {
                        let vec9 = e;
                        let ptr9 = vec9.as_ptr().cast::<u8>();
                        let len9 = vec9.len();
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                        *base.add(0).cast::<*mut u8>() = ptr9.cast_mut();
                      }
                    }
                    *ptr0.add(72+10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                    *ptr0.add(72+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result10;
                  },
                  None => {
                    {
                      *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match entrypoint8 {
                  Some(e) => {
                    *ptr0.add(72+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec12 = e;
                    let len12 = vec12.len();
                    let layout12 = _rt::alloc::Layout::from_size_align(vec12.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                    let (result12, _cleanup12) = wit_bindgen::rt::Cleanup::new(layout12);cleanup_list.extend(_cleanup12);
                    for (i, e) in vec12.into_iter().enumerate() {
                      let base = result12.add(i * (2*::core::mem::size_of::<*const u8>()));
                      {
                        let vec11 = e;
                        let ptr11 = vec11.as_ptr().cast::<u8>();
                        let len11 = vec11.len();
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                        *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                      }
                    }
                    *ptr0.add(72+13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                    *ptr0.add(72+12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result12;
                  },
                  None => {
                    {
                      *ptr0.add(72+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match exec8 {
                  Some(e) => {
                    *ptr0.add(72+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec14 = e;
                    let len14 = vec14.len();
                    let layout14 = _rt::alloc::Layout::from_size_align(vec14.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                    let (result14, _cleanup14) = wit_bindgen::rt::Cleanup::new(layout14);cleanup_list.extend(_cleanup14);
                    for (i, e) in vec14.into_iter().enumerate() {
                      let base = result14.add(i * (2*::core::mem::size_of::<*const u8>()));
                      {
                        let vec13 = e;
                        let ptr13 = vec13.as_ptr().cast::<u8>();
                        let len13 = vec13.len();
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                        *base.add(0).cast::<*mut u8>() = ptr13.cast_mut();
                      }
                    }
                    *ptr0.add(72+16*::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
                    *ptr0.add(72+15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result14;
                  },
                  None => {
                    {
                      *ptr0.add(72+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match kernel_args8 {
                  Some(e) => {
                    *ptr0.add(72+17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec16 = e;
                    let len16 = vec16.len();
                    let layout16 = _rt::alloc::Layout::from_size_align(vec16.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                    let (result16, _cleanup16) = wit_bindgen::rt::Cleanup::new(layout16);cleanup_list.extend(_cleanup16);
                    for (i, e) in vec16.into_iter().enumerate() {
                      let base = result16.add(i * (2*::core::mem::size_of::<*const u8>()));
                      {
                        let vec15 = e;
                        let ptr15 = vec15.as_ptr().cast::<u8>();
                        let len15 = vec15.len();
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
                        *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                      }
                    }
                    *ptr0.add(72+19*::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                    *ptr0.add(72+18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result16;
                  },
                  None => {
                    {
                      *ptr0.add(72+17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match swap_size_mb8 {
                  Some(e) => {
                    *ptr0.add(72+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(80+20*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                  },
                  None => {
                    {
                      *ptr0.add(72+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match tty8 {
                  Some(e) => {
                    *ptr0.add(88+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(89+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(88+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };},
                None => {
                  {
                    *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match env3 {
                Some(e) => {
                  *ptr0.add(96+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let vec20 = e;
                  let len20 = vec20.len();
                  let layout20 = _rt::alloc::Layout::from_size_align(vec20.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                  let (result20, _cleanup20) = wit_bindgen::rt::Cleanup::new(layout20);cleanup_list.extend(_cleanup20);
                  for (i, e) in vec20.into_iter().enumerate() {
                    let base = result20.add(i * (4*::core::mem::size_of::<*const u8>()));
                    {
                      let (t17_0, t17_1, ) = e;
                      let vec18 = t17_0;
                      let ptr18 = vec18.as_ptr().cast::<u8>();
                      let len18 = vec18.len();
                      *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
                      *base.add(0).cast::<*mut u8>() = ptr18.cast_mut();
                      let vec19 = t17_1;
                      let ptr19 = vec19.as_ptr().cast::<u8>();
                      let len19 = vec19.len();
                      *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
                      *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr19.cast_mut();
                    }
                  }
                  *ptr0.add(96+22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len20;
                  *ptr0.add(96+21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result20;
                },
                None => {
                  {
                    *ptr0.add(96+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match restart3 {
                Some(e) => {
                  *ptr0.add(96+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let MachineRestart{ max_retries:max_retries21, policy:policy21, } = e;
                  match max_retries21 {
                    Some(e) => {
                      *ptr0.add(100+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      *ptr0.add(104+23*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                    },
                    None => {
                      {
                        *ptr0.add(100+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };*ptr0.add(108+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (policy21.clone() as i32) as u8;
                },
                None => {
                  {
                    *ptr0.add(96+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };match stop_config3 {
                Some(e) => {
                  *ptr0.add(120+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                  let StopConfig{ signal:signal22, timeout:timeout22, } = e;
                  match signal22 {
                    Some(e) => {
                      *ptr0.add(128+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let vec23 = e;
                      let ptr23 = vec23.as_ptr().cast::<u8>();
                      let len23 = vec23.len();
                      *ptr0.add(128+24*::core::mem::size_of::<*const u8>()).cast::<usize>() = len23;
                      *ptr0.add(128+23*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr23.cast_mut();
                    },
                    None => {
                      {
                        *ptr0.add(128+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match timeout22 {
                    Some(e) => {
                      *ptr0.add(136+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      *ptr0.add(144+24*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                    },
                    None => {
                      {
                        *ptr0.add(136+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                  None => {
                    {
                      *ptr0.add(120+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match mounts3 {
                  Some(e) => {
                    *ptr0.add(152+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec27 = e;
                    let len27 = vec27.len();
                    let layout27 = _rt::alloc::Layout::from_size_align(vec27.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                    let (result27, _cleanup27) = wit_bindgen::rt::Cleanup::new(layout27);cleanup_list.extend(_cleanup27);
                    for (i, e) in vec27.into_iter().enumerate() {
                      let base = result27.add(i * (4*::core::mem::size_of::<*const u8>()));
                      {
                        let Mount{ volume:volume24, path:path24, } = e;
                        let vec25 = volume24;
                        let ptr25 = vec25.as_ptr().cast::<u8>();
                        let len25 = vec25.len();
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len25;
                        *base.add(0).cast::<*mut u8>() = ptr25.cast_mut();
                        let vec26 = path24;
                        let ptr26 = vec26.as_ptr().cast::<u8>();
                        let len26 = vec26.len();
                        *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len26;
                        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr26.cast_mut();
                      }
                    }
                    *ptr0.add(152+26*::core::mem::size_of::<*const u8>()).cast::<usize>() = len27;
                    *ptr0.add(152+25*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result27;
                  },
                  None => {
                    {
                      *ptr0.add(152+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match services3 {
                  Some(e) => {
                    *ptr0.add(152+27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec32 = e;
                    let len32 = vec32.len();
                    let layout32 = _rt::alloc::Layout::from_size_align(vec32.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                    let (result32, _cleanup32) = wit_bindgen::rt::Cleanup::new(layout32);cleanup_list.extend(_cleanup32);
                    for (i, e) in vec32.into_iter().enumerate() {
                      let base = result32.add(i * (3*::core::mem::size_of::<*const u8>()));
                      {
                        let ServiceConfig{ internal_port:internal_port28, protocol:protocol28, ports:ports28, } = e;
                        *base.add(0).cast::<u16>() = (_rt::as_i32(internal_port28)) as u16;
                        *base.add(2).cast::<u8>() = (protocol28.clone() as i32) as u8;
                        let vec31 = ports28;
                        let len31 = vec31.len();
                        let layout31 = _rt::alloc::Layout::from_size_align(vec31.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                        let (result31, _cleanup31) = wit_bindgen::rt::Cleanup::new(layout31);cleanup_list.extend(_cleanup31);
                        for (i, e) in vec31.into_iter().enumerate() {
                          let base = result31.add(i * (3*::core::mem::size_of::<*const u8>()));
                          {
                            let PortConfig{ port:port29, handlers:handlers29, } = e;
                            *base.add(0).cast::<u16>() = (_rt::as_i32(port29)) as u16;
                            let vec30 = handlers29;
                            let len30 = vec30.len();
                            let layout30 = _rt::alloc::Layout::from_size_align(vec30.len() * 1, 1).unwrap();
                            let (result30, _cleanup30) = wit_bindgen::rt::Cleanup::new(layout30);cleanup_list.extend(_cleanup30);
                            for (i, e) in vec30.into_iter().enumerate() {
                              let base = result30.add(i * 1);
                              {
                                *base.add(0).cast::<u8>() = (e.clone() as i32) as u8;
                              }
                            }
                            *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len30;
                            *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result30;
                          }
                        }
                        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len31;
                        *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result31;
                      }
                    }
                    *ptr0.add(152+29*::core::mem::size_of::<*const u8>()).cast::<usize>() = len32;
                    *ptr0.add(152+28*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result32;
                  },
                  None => {
                    {
                      *ptr0.add(152+27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match region {
                  Some(e) => {
                    *ptr0.add(152+30*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(153+30*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(152+30*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };let ptr33 = ret_area.0.as_mut_ptr().cast::<u8>();
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                unsafe extern "C" {
                  #[link_name = "create"]
                  fn wit_import34(_: *mut u8, _: *mut u8, );
                }

                #[cfg(not(target_arch = "wasm32"))]
                unsafe extern "C" fn wit_import34(_: *mut u8, _: *mut u8, ) { unreachable!() }
                wit_import34(ptr0, ptr33);
                let l35 = i32::from(*ptr33.add(0).cast::<u8>());
                let result42 = match l35 {
                  0 => {
                    let e = {
                      let l36 = *ptr33.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l37 = *ptr33.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len38 = l37;
                      let bytes38 = _rt::Vec::from_raw_parts(l36.cast(), len38, len38);

                      _rt::string_lift(bytes38)
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l39 = *ptr33.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l40 = *ptr33.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len41 = l40;
                      let bytes41 = _rt::Vec::from_raw_parts(l39.cast(), len41, len41);

                      _rt::string_lift(bytes41)
                    };
                    Err(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                };
                result42
              }
            }
            #[allow(unused_unsafe, clippy::all)]
            #[allow(async_fn_in_trait)]
            pub fn update(app_name: &str,machine_id: &str,machine_config: &MachineConfig,region: Option<Region>,) -> Result<(),_rt::String>{
              unsafe {
                let mut cleanup_list = _rt::Vec::new();

                #[repr(align(8))]
                struct RetArea([::core::mem::MaybeUninit::<u8>; 160+30*::core::mem::size_of::<*const u8>()]);
                let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 160+30*::core::mem::size_of::<*const u8>()]);
                let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();let vec1 = app_name;
                let ptr1 = vec1.as_ptr().cast::<u8>();
                let len1 = vec1.len();
                *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
                *ptr0.add(0).cast::<*mut u8>() = ptr1.cast_mut();
                let vec2 = machine_id;
                let ptr2 = vec2.as_ptr().cast::<u8>();
                let len2 = vec2.len();
                *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
                let MachineConfig{ image:image3, guest:guest3, auto_destroy:auto_destroy3, init:init3, env:env3, restart:restart3, stop_config:stop_config3, mounts:mounts3, services:services3, } = machine_config;
                let vec4 = image3;
                let ptr4 = vec4.as_ptr().cast::<u8>();
                let len4 = vec4.len();
                *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                match guest3 {
                  Some(e) => {
                    *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let GuestConfig{ cpu_kind:cpu_kind5, cpus:cpus5, memory_mb:memory_mb5, kernel_args:kernel_args5, } = e;
                    match cpu_kind5 {
                      Some(e) => {
                        *ptr0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        *ptr0.add(9+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                      },
                      None => {
                        {
                          *ptr0.add(8+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match cpus5 {
                      Some(e) => {
                        *ptr0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        *ptr0.add(24+6*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                      },
                      None => {
                        {
                          *ptr0.add(16+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match memory_mb5 {
                      Some(e) => {
                        *ptr0.add(32+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        *ptr0.add(40+6*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                      },
                      None => {
                        {
                          *ptr0.add(32+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match kernel_args5 {
                      Some(e) => {
                        *ptr0.add(48+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec7 = e;
                        let len7 = vec7.len();
                        let layout7 = _rt::alloc::Layout::from_size_align(vec7.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                        let (result7, _cleanup7) = wit_bindgen::rt::Cleanup::new(layout7);cleanup_list.extend(_cleanup7);
                        for (i, e) in vec7.into_iter().enumerate() {
                          let base = result7.add(i * (2*::core::mem::size_of::<*const u8>()));
                          {
                            let vec6 = e;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                          }
                        }
                        *ptr0.add(48+8*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                        *ptr0.add(48+7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result7;
                      },
                      None => {
                        {
                          *ptr0.add(48+6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };},
                    None => {
                      {
                        *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match auto_destroy3 {
                    Some(e) => {
                      *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      *ptr0.add(57+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                    },
                    None => {
                      {
                        *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match init3 {
                    Some(e) => {
                      *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                      let InitConfig{ cmd:cmd8, entrypoint:entrypoint8, exec:exec8, kernel_args:kernel_args8, swap_size_mb:swap_size_mb8, tty:tty8, } = e;
                      match cmd8 {
                        Some(e) => {
                          *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec10 = e;
                          let len10 = vec10.len();
                          let layout10 = _rt::alloc::Layout::from_size_align(vec10.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                          let (result10, _cleanup10) = wit_bindgen::rt::Cleanup::new(layout10);cleanup_list.extend(_cleanup10);
                          for (i, e) in vec10.into_iter().enumerate() {
                            let base = result10.add(i * (2*::core::mem::size_of::<*const u8>()));
                            {
                              let vec9 = e;
                              let ptr9 = vec9.as_ptr().cast::<u8>();
                              let len9 = vec9.len();
                              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                              *base.add(0).cast::<*mut u8>() = ptr9.cast_mut();
                            }
                          }
                          *ptr0.add(72+10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
                          *ptr0.add(72+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result10;
                        },
                        None => {
                          {
                            *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match entrypoint8 {
                        Some(e) => {
                          *ptr0.add(72+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec12 = e;
                          let len12 = vec12.len();
                          let layout12 = _rt::alloc::Layout::from_size_align(vec12.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                          let (result12, _cleanup12) = wit_bindgen::rt::Cleanup::new(layout12);cleanup_list.extend(_cleanup12);
                          for (i, e) in vec12.into_iter().enumerate() {
                            let base = result12.add(i * (2*::core::mem::size_of::<*const u8>()));
                            {
                              let vec11 = e;
                              let ptr11 = vec11.as_ptr().cast::<u8>();
                              let len11 = vec11.len();
                              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                              *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                            }
                          }
                          *ptr0.add(72+13*::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                          *ptr0.add(72+12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result12;
                        },
                        None => {
                          {
                            *ptr0.add(72+11*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match exec8 {
                        Some(e) => {
                          *ptr0.add(72+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec14 = e;
                          let len14 = vec14.len();
                          let layout14 = _rt::alloc::Layout::from_size_align(vec14.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                          let (result14, _cleanup14) = wit_bindgen::rt::Cleanup::new(layout14);cleanup_list.extend(_cleanup14);
                          for (i, e) in vec14.into_iter().enumerate() {
                            let base = result14.add(i * (2*::core::mem::size_of::<*const u8>()));
                            {
                              let vec13 = e;
                              let ptr13 = vec13.as_ptr().cast::<u8>();
                              let len13 = vec13.len();
                              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len13;
                              *base.add(0).cast::<*mut u8>() = ptr13.cast_mut();
                            }
                          }
                          *ptr0.add(72+16*::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
                          *ptr0.add(72+15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result14;
                        },
                        None => {
                          {
                            *ptr0.add(72+14*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match kernel_args8 {
                        Some(e) => {
                          *ptr0.add(72+17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec16 = e;
                          let len16 = vec16.len();
                          let layout16 = _rt::alloc::Layout::from_size_align(vec16.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                          let (result16, _cleanup16) = wit_bindgen::rt::Cleanup::new(layout16);cleanup_list.extend(_cleanup16);
                          for (i, e) in vec16.into_iter().enumerate() {
                            let base = result16.add(i * (2*::core::mem::size_of::<*const u8>()));
                            {
                              let vec15 = e;
                              let ptr15 = vec15.as_ptr().cast::<u8>();
                              let len15 = vec15.len();
                              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
                              *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                            }
                          }
                          *ptr0.add(72+19*::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                          *ptr0.add(72+18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result16;
                        },
                        None => {
                          {
                            *ptr0.add(72+17*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match swap_size_mb8 {
                        Some(e) => {
                          *ptr0.add(72+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr0.add(80+20*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                        },
                        None => {
                          {
                            *ptr0.add(72+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match tty8 {
                        Some(e) => {
                          *ptr0.add(88+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr0.add(89+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                        },
                        None => {
                          {
                            *ptr0.add(88+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      None => {
                        {
                          *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match env3 {
                      Some(e) => {
                        *ptr0.add(96+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec20 = e;
                        let len20 = vec20.len();
                        let layout20 = _rt::alloc::Layout::from_size_align(vec20.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                        let (result20, _cleanup20) = wit_bindgen::rt::Cleanup::new(layout20);cleanup_list.extend(_cleanup20);
                        for (i, e) in vec20.into_iter().enumerate() {
                          let base = result20.add(i * (4*::core::mem::size_of::<*const u8>()));
                          {
                            let (t17_0, t17_1, ) = e;
                            let vec18 = t17_0;
                            let ptr18 = vec18.as_ptr().cast::<u8>();
                            let len18 = vec18.len();
                            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
                            *base.add(0).cast::<*mut u8>() = ptr18.cast_mut();
                            let vec19 = t17_1;
                            let ptr19 = vec19.as_ptr().cast::<u8>();
                            let len19 = vec19.len();
                            *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
                            *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr19.cast_mut();
                          }
                        }
                        *ptr0.add(96+22*::core::mem::size_of::<*const u8>()).cast::<usize>() = len20;
                        *ptr0.add(96+21*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result20;
                      },
                      None => {
                        {
                          *ptr0.add(96+20*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match restart3 {
                      Some(e) => {
                        *ptr0.add(96+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let MachineRestart{ max_retries:max_retries21, policy:policy21, } = e;
                        match max_retries21 {
                          Some(e) => {
                            *ptr0.add(100+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(104+23*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                          },
                          None => {
                            {
                              *ptr0.add(100+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };*ptr0.add(108+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (policy21.clone() as i32) as u8;
                      },
                      None => {
                        {
                          *ptr0.add(96+23*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match stop_config3 {
                      Some(e) => {
                        *ptr0.add(120+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let StopConfig{ signal:signal22, timeout:timeout22, } = e;
                        match signal22 {
                          Some(e) => {
                            *ptr0.add(128+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec23 = e;
                            let ptr23 = vec23.as_ptr().cast::<u8>();
                            let len23 = vec23.len();
                            *ptr0.add(128+24*::core::mem::size_of::<*const u8>()).cast::<usize>() = len23;
                            *ptr0.add(128+23*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr23.cast_mut();
                          },
                          None => {
                            {
                              *ptr0.add(128+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };match timeout22 {
                          Some(e) => {
                            *ptr0.add(136+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(144+24*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                          },
                          None => {
                            {
                              *ptr0.add(136+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };},
                        None => {
                          {
                            *ptr0.add(120+22*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match mounts3 {
                        Some(e) => {
                          *ptr0.add(152+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec27 = e;
                          let len27 = vec27.len();
                          let layout27 = _rt::alloc::Layout::from_size_align(vec27.len() * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                          let (result27, _cleanup27) = wit_bindgen::rt::Cleanup::new(layout27);cleanup_list.extend(_cleanup27);
                          for (i, e) in vec27.into_iter().enumerate() {
                            let base = result27.add(i * (4*::core::mem::size_of::<*const u8>()));
                            {
                              let Mount{ volume:volume24, path:path24, } = e;
                              let vec25 = volume24;
                              let ptr25 = vec25.as_ptr().cast::<u8>();
                              let len25 = vec25.len();
                              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len25;
                              *base.add(0).cast::<*mut u8>() = ptr25.cast_mut();
                              let vec26 = path24;
                              let ptr26 = vec26.as_ptr().cast::<u8>();
                              let len26 = vec26.len();
                              *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len26;
                              *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr26.cast_mut();
                            }
                          }
                          *ptr0.add(152+26*::core::mem::size_of::<*const u8>()).cast::<usize>() = len27;
                          *ptr0.add(152+25*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result27;
                        },
                        None => {
                          {
                            *ptr0.add(152+24*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match services3 {
                        Some(e) => {
                          *ptr0.add(152+27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          let vec32 = e;
                          let len32 = vec32.len();
                          let layout32 = _rt::alloc::Layout::from_size_align(vec32.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                          let (result32, _cleanup32) = wit_bindgen::rt::Cleanup::new(layout32);cleanup_list.extend(_cleanup32);
                          for (i, e) in vec32.into_iter().enumerate() {
                            let base = result32.add(i * (3*::core::mem::size_of::<*const u8>()));
                            {
                              let ServiceConfig{ internal_port:internal_port28, protocol:protocol28, ports:ports28, } = e;
                              *base.add(0).cast::<u16>() = (_rt::as_i32(internal_port28)) as u16;
                              *base.add(2).cast::<u8>() = (protocol28.clone() as i32) as u8;
                              let vec31 = ports28;
                              let len31 = vec31.len();
                              let layout31 = _rt::alloc::Layout::from_size_align(vec31.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                              let (result31, _cleanup31) = wit_bindgen::rt::Cleanup::new(layout31);cleanup_list.extend(_cleanup31);
                              for (i, e) in vec31.into_iter().enumerate() {
                                let base = result31.add(i * (3*::core::mem::size_of::<*const u8>()));
                                {
                                  let PortConfig{ port:port29, handlers:handlers29, } = e;
                                  *base.add(0).cast::<u16>() = (_rt::as_i32(port29)) as u16;
                                  let vec30 = handlers29;
                                  let len30 = vec30.len();
                                  let layout30 = _rt::alloc::Layout::from_size_align(vec30.len() * 1, 1).unwrap();
                                  let (result30, _cleanup30) = wit_bindgen::rt::Cleanup::new(layout30);cleanup_list.extend(_cleanup30);
                                  for (i, e) in vec30.into_iter().enumerate() {
                                    let base = result30.add(i * 1);
                                    {
                                      *base.add(0).cast::<u8>() = (e.clone() as i32) as u8;
                                    }
                                  }
                                  *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len30;
                                  *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result30;
                                }
                              }
                              *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len31;
                              *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result31;
                            }
                          }
                          *ptr0.add(152+29*::core::mem::size_of::<*const u8>()).cast::<usize>() = len32;
                          *ptr0.add(152+28*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result32;
                        },
                        None => {
                          {
                            *ptr0.add(152+27*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match region {
                        Some(e) => {
                          *ptr0.add(152+30*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                          *ptr0.add(153+30*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                        },
                        None => {
                          {
                            *ptr0.add(152+30*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };let ptr33 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                      unsafe extern "C" {
                        #[link_name = "update"]
                        fn wit_import34(_: *mut u8, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import34(_: *mut u8, _: *mut u8, ) { unreachable!() }
                      wit_import34(ptr0, ptr33);
                      let l35 = i32::from(*ptr33.add(0).cast::<u8>());
                      let result39 = match l35 {
                        0 => {
                          let e = ();
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l36 = *ptr33.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l37 = *ptr33.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len38 = l37;
                            let bytes38 = _rt::Vec::from_raw_parts(l36.cast(), len38, len38);

                            _rt::string_lift(bytes38)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result39
                    }
                  }
                  #[allow(unused_unsafe, clippy::all)]
                  #[allow(async_fn_in_trait)]
                  pub fn suspend(app_name: &str,machine_id: &str,) -> Result<(),_rt::String>{
                    unsafe {

                      #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                      #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                      struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
                      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
                      let vec0 = app_name;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      let vec1 = machine_id;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                      unsafe extern "C" {
                        #[link_name = "suspend"]
                        fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                      wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                      let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                      let result8 = match l4 {
                        0 => {
                          let e = ();
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                            _rt::string_lift(bytes7)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result8
                    }
                  }
                  #[allow(unused_unsafe, clippy::all)]
                  #[allow(async_fn_in_trait)]
                  pub fn stop(app_name: &str,machine_id: &str,) -> Result<(),_rt::String>{
                    unsafe {

                      #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                      #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                      struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
                      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
                      let vec0 = app_name;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      let vec1 = machine_id;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                      unsafe extern "C" {
                        #[link_name = "stop"]
                        fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                      wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                      let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                      let result8 = match l4 {
                        0 => {
                          let e = ();
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                            _rt::string_lift(bytes7)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result8
                    }
                  }
                  #[allow(unused_unsafe, clippy::all)]
                  #[allow(async_fn_in_trait)]
                  pub fn start(app_name: &str,machine_id: &str,) -> Result<(),_rt::String>{
                    unsafe {

                      #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                      #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                      struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
                      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
                      let vec0 = app_name;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      let vec1 = machine_id;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                      unsafe extern "C" {
                        #[link_name = "start"]
                        fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                      wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                      let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                      let result8 = match l4 {
                        0 => {
                          let e = ();
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                            _rt::string_lift(bytes7)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result8
                    }
                  }
                  #[allow(unused_unsafe, clippy::all)]
                  #[allow(async_fn_in_trait)]
                  pub fn restart(app_name: &str,machine_id: &str,) -> Result<(),_rt::String>{
                    unsafe {

                      #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                      #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                      struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
                      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
                      let vec0 = app_name;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      let vec1 = machine_id;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                      unsafe extern "C" {
                        #[link_name = "restart"]
                        fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                      wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                      let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                      let result8 = match l4 {
                        0 => {
                          let e = ();
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                            _rt::string_lift(bytes7)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result8
                    }
                  }
                  #[allow(unused_unsafe, clippy::all)]
                  #[allow(async_fn_in_trait)]
                  pub fn delete(app_name: &str,machine_id: &str,force: bool,) -> Result<(),_rt::String>{
                    unsafe {

                      #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                      #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                      struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
                      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
                      let vec0 = app_name;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      let vec1 = machine_id;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                      unsafe extern "C" {
                        #[link_name = "delete"]
                        fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import3(_: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, ) { unreachable!() }
                      wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, match &force { true => 1, false => 0 }, ptr2);
                      let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                      let result8 = match l4 {
                        0 => {
                          let e = ();
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len7 = l6;
                            let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                            _rt::string_lift(bytes7)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result8
                    }
                  }
                  #[allow(unused_unsafe, clippy::all)]
                  #[allow(async_fn_in_trait)]
                  pub fn exec(app_name: &str,machine_id: &str,command: &[_rt::String],) -> Result<ExecResponse,_rt::String>{
                    unsafe {

                      #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                      #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                      struct RetArea([::core::mem::MaybeUninit::<u8>; 16+7*::core::mem::size_of::<*const u8>()]);
                      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16+7*::core::mem::size_of::<*const u8>()]);
                      let vec0 = app_name;
                      let ptr0 = vec0.as_ptr().cast::<u8>();
                      let len0 = vec0.len();
                      let vec1 = machine_id;
                      let ptr1 = vec1.as_ptr().cast::<u8>();
                      let len1 = vec1.len();
                      let vec3 = command;
                      let len3 = vec3.len();
                      let layout3 = _rt::alloc::Layout::from_size_align(vec3.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                      let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(layout3);for (i, e) in vec3.into_iter().enumerate() {
                        let base = result3.add(i * (2*::core::mem::size_of::<*const u8>()));
                        {
                          let vec2 = e;
                          let ptr2 = vec2.as_ptr().cast::<u8>();
                          let len2 = vec2.len();
                          *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                          *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                      }
                      let ptr4 = ret_area.0.as_mut_ptr().cast::<u8>();
                      #[cfg(target_arch = "wasm32")]
                      #[link(wasm_import_module = "obelisk-flyio:activity-fly-http/machines@1.0.0-beta")]
                      unsafe extern "C" {
                        #[link_name = "exec"]
                        fn wit_import5(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
                      }

                      #[cfg(not(target_arch = "wasm32"))]
                      unsafe extern "C" fn wit_import5(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                      wit_import5(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, result3, len3, ptr4);
                      let l6 = i32::from(*ptr4.add(0).cast::<u8>());
                      let result22 = match l6 {
                        0 => {
                          let e = {
                            let l7 = i32::from(*ptr4.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                            let l9 = i32::from(*ptr4.add(8+1*::core::mem::size_of::<*const u8>()).cast::<u8>());
                            let l11 = i32::from(*ptr4.add(16+1*::core::mem::size_of::<*const u8>()).cast::<u8>());
                            let l15 = i32::from(*ptr4.add(16+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                            ExecResponse{
                              exit_code: match l7 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l8 = *ptr4.add(4+1*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                    l8
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                              exit_signal: match l9 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l10 = *ptr4.add(12+1*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                    l10
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                              stderr: match l11 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l12 = *ptr4.add(16+2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l13 = *ptr4.add(16+3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    let len14 = l13;
                                    let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);

                                    _rt::string_lift(bytes14)
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                              stdout: match l15 {
                                0 => None,
                                1 => {
                                  let e = {
                                    let l16 = *ptr4.add(16+5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                    let l17 = *ptr4.add(16+6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                    let len18 = l17;
                                    let bytes18 = _rt::Vec::from_raw_parts(l16.cast(), len18, len18);

                                    _rt::string_lift(bytes18)
                                  };
                                  Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                              },
                            }
                          };
                          Ok(e)
                        }
                        1 => {
                          let e = {
                            let l19 = *ptr4.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l20 = *ptr4.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len21 = l20;
                            let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);

                            _rt::string_lift(bytes21)
                          };
                          Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                      };
                      result22
                    }
                  }

                }

              }
            }
            #[allow(dead_code, clippy::all)]
            pub mod exports {
              pub mod obelisk_flyio {
                pub mod workflow {

                  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
                  pub mod workflow {
                    #[used]
                    #[doc(hidden)]
                    static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                    
                    use super::super::super::super::_rt;
                    /// Same syntax as in obelisk.toml - "key" or "key=val"
                    pub type EnvVar = _rt::String;
                    #[derive(Clone)]
                    pub struct VolumeConfig {
                      pub size_in_gb: u16,
                      pub name: _rt::String,
                    }
                    impl ::core::fmt::Debug for VolumeConfig {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("VolumeConfig").field("size-in-gb", &self.size_in_gb).field("name", &self.name).finish()
                      }
                    }
                    #[derive(Clone)]
                    pub struct ActivityWasm {
                      pub name: _rt::String,
                      pub location_oci: _rt::String,
                      pub env_vars: Option<_rt::Vec::<EnvVar>>,
                      pub lock_expiry_seconds: Option<u32>,
                    }
                    impl ::core::fmt::Debug for ActivityWasm {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("ActivityWasm").field("name", &self.name).field("location-oci", &self.location_oci).field("env-vars", &self.env_vars).field("lock-expiry-seconds", &self.lock_expiry_seconds).finish()
                      }
                    }
                    #[derive(Clone)]
                    pub struct Workflow {
                      pub name: _rt::String,
                      pub location_oci: _rt::String,
                    }
                    impl ::core::fmt::Debug for Workflow {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Workflow").field("name", &self.name).field("location-oci", &self.location_oci).finish()
                      }
                    }
                    #[derive(Clone)]
                    pub struct Route {
                      pub methods: _rt::Vec::<_rt::String>,
                      pub path: _rt::String,
                    }
                    impl ::core::fmt::Debug for Route {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Route").field("methods", &self.methods).field("path", &self.path).finish()
                      }
                    }
                    #[derive(Clone)]
                    pub struct WebhokEndpoint {
                      pub name: _rt::String,
                      pub location_oci: _rt::String,
                      pub routes: _rt::Vec::<Route>,
                      pub env_vars: Option<_rt::Vec::<EnvVar>>,
                    }
                    impl ::core::fmt::Debug for WebhokEndpoint {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("WebhokEndpoint").field("name", &self.name).field("location-oci", &self.location_oci).field("routes", &self.routes).field("env-vars", &self.env_vars).finish()
                      }
                    }
                    #[derive(Clone)]
                    pub struct ObeliskConfig {
                      pub activity_wasm_list: Option<_rt::Vec::<ActivityWasm>>,
                      pub workflow_list: Option<_rt::Vec::<Workflow>>,
                      pub webhook_endpoint_list: Option<_rt::Vec::<WebhokEndpoint>>,
                    }
                    impl ::core::fmt::Debug for ObeliskConfig {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("ObeliskConfig").field("activity-wasm-list", &self.activity_wasm_list).field("workflow-list", &self.workflow_list).field("webhook-endpoint-list", &self.webhook_endpoint_list).finish()
                      }
                    }
                    #[derive(Clone)]
                    pub struct SecretKey {
                      pub name: _rt::String,
                      /// Set to true if the app already contains this secret.
                      pub present: bool,
                    }
                    impl ::core::fmt::Debug for SecretKey {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("SecretKey").field("name", &self.name).field("present", &self.present).finish()
                      }
                    }
                    #[derive(Clone)]
                    pub enum AppCreateError {
                      /// Name alreay taken
                      Conflict,
                      /// Cannot create the volume
                      VolumeCreateError(_rt::String),
                      /// Cannot start the temporary VM
                      TempVmError(_rt::String),
                      /// Cannot place files on the volume.
                      VolumeWriteError(_rt::String),
                      /// Error running `obelisk server verify -i`
                      VerifyError(_rt::String),
                    }
                    impl ::core::fmt::Debug for AppCreateError {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          AppCreateError::Conflict => {
                            f.debug_tuple("AppCreateError::Conflict").finish()
                          }
                          AppCreateError::VolumeCreateError(e) => {
                            f.debug_tuple("AppCreateError::VolumeCreateError").field(e).finish()
                          }
                          AppCreateError::TempVmError(e) => {
                            f.debug_tuple("AppCreateError::TempVmError").field(e).finish()
                          }
                          AppCreateError::VolumeWriteError(e) => {
                            f.debug_tuple("AppCreateError::VolumeWriteError").field(e).finish()
                          }
                          AppCreateError::VerifyError(e) => {
                            f.debug_tuple("AppCreateError::VerifyError").field(e).finish()
                          }
                        }
                      }
                    }
                    impl ::core::fmt::Display for AppCreateError {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        write!(f, "{:?}", self)
                      }
                    }

                    impl std::error::Error for AppCreateError {}
                    #[derive(Clone)]
                    pub enum ServeError {
                      VmStartError(_rt::String),
                      HealthcheckError(_rt::String),
                    }
                    impl ::core::fmt::Debug for ServeError {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        match self {
                          ServeError::VmStartError(e) => {
                            f.debug_tuple("ServeError::VmStartError").field(e).finish()
                          }
                          ServeError::HealthcheckError(e) => {
                            f.debug_tuple("ServeError::HealthcheckError").field(e).finish()
                          }
                        }
                      }
                    }
                    impl ::core::fmt::Display for ServeError {
                      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        write!(f, "{:?}", self)
                      }
                    }

                    impl std::error::Error for ServeError {}
                    #[doc(hidden)]
                    #[allow(non_snake_case, unused_unsafe)]
                    pub unsafe fn _export_app_create_cabi<T: Guest>(arg0: *mut u8,arg1: usize,arg2: i32,arg3: *mut u8,arg4: usize,arg5: i32,arg6: *mut u8,arg7: usize,arg8: i32,arg9: *mut u8,arg10: usize,arg11: i32,arg12: *mut u8,arg13: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                    _rt::run_ctors_once();let result51 = {
                      let len0 = arg1;
                      let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                      let len1 = arg4;
                      let bytes1 = _rt::Vec::from_raw_parts(arg3.cast(), len1, len1);
                      T::app_create(_rt::string_lift(bytes0), VolumeConfig{
                        size_in_gb: arg2 as u16,
                        name: _rt::string_lift(bytes1),
                      }, ObeliskConfig{
                        activity_wasm_list: match arg5 {
                          0 => None,
                          1 => {
                            let e = {
                              let base17 = arg6;
                              let len17 = arg7;
                              let mut result17 = _rt::Vec::with_capacity(len17);
                              for i in 0..len17 {
                                let base = base17.add(i * (8+7*::core::mem::size_of::<*const u8>()));
                                let e17 = {
                                  let l2 = *base.add(0).cast::<*mut u8>();
                                  let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len4 = l3;
                                  let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                  let l5 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l6 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len7 = l6;
                                  let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                                  let l8 = i32::from(*base.add(4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                  let l15 = i32::from(*base.add(7*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                  ActivityWasm{
                                    name: _rt::string_lift(bytes4),
                                    location_oci: _rt::string_lift(bytes7),
                                    env_vars: match l8 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l9 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                          let l10 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let base14 = l9;
                                          let len14 = l10;
                                          let mut result14 = _rt::Vec::with_capacity(len14);
                                          for i in 0..len14 {
                                            let base = base14.add(i * (2*::core::mem::size_of::<*const u8>()));
                                            let e14 = {
                                              let l11 = *base.add(0).cast::<*mut u8>();
                                              let l12 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                              let len13 = l12;
                                              let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                                              _rt::string_lift(bytes13)
                                            };
                                            result14.push(e14);
                                          }
                                          _rt::cabi_dealloc(base14, len14 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                          result14
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    },
                                    lock_expiry_seconds: match l15 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l16 = *base.add(4+7*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                          l16 as u32
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    },
                                  }
                                };
                                result17.push(e17);
                              }
                              _rt::cabi_dealloc(base17, len17 * (8+7*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                              result17
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        workflow_list: match arg8 {
                          0 => None,
                          1 => {
                            let e = {
                              let base24 = arg9;
                              let len24 = arg10;
                              let mut result24 = _rt::Vec::with_capacity(len24);
                              for i in 0..len24 {
                                let base = base24.add(i * (4*::core::mem::size_of::<*const u8>()));
                                let e24 = {
                                  let l18 = *base.add(0).cast::<*mut u8>();
                                  let l19 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len20 = l19;
                                  let bytes20 = _rt::Vec::from_raw_parts(l18.cast(), len20, len20);
                                  let l21 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l22 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len23 = l22;
                                  let bytes23 = _rt::Vec::from_raw_parts(l21.cast(), len23, len23);

                                  Workflow{
                                    name: _rt::string_lift(bytes20),
                                    location_oci: _rt::string_lift(bytes23),
                                  }
                                };
                                result24.push(e24);
                              }
                              _rt::cabi_dealloc(base24, len24 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                              result24
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                        webhook_endpoint_list: match arg11 {
                          0 => None,
                          1 => {
                            let e = {
                              let base50 = arg12;
                              let len50 = arg13;
                              let mut result50 = _rt::Vec::with_capacity(len50);
                              for i in 0..len50 {
                                let base = base50.add(i * (9*::core::mem::size_of::<*const u8>()));
                                let e50 = {
                                  let l25 = *base.add(0).cast::<*mut u8>();
                                  let l26 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len27 = l26;
                                  let bytes27 = _rt::Vec::from_raw_parts(l25.cast(), len27, len27);
                                  let l28 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l29 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let len30 = l29;
                                  let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);
                                  let l31 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                  let l32 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                  let base42 = l31;
                                  let len42 = l32;
                                  let mut result42 = _rt::Vec::with_capacity(len42);
                                  for i in 0..len42 {
                                    let base = base42.add(i * (4*::core::mem::size_of::<*const u8>()));
                                    let e42 = {
                                      let l33 = *base.add(0).cast::<*mut u8>();
                                      let l34 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let base38 = l33;
                                      let len38 = l34;
                                      let mut result38 = _rt::Vec::with_capacity(len38);
                                      for i in 0..len38 {
                                        let base = base38.add(i * (2*::core::mem::size_of::<*const u8>()));
                                        let e38 = {
                                          let l35 = *base.add(0).cast::<*mut u8>();
                                          let l36 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let len37 = l36;
                                          let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);

                                          _rt::string_lift(bytes37)
                                        };
                                        result38.push(e38);
                                      }
                                      _rt::cabi_dealloc(base38, len38 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                                      let l39 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                      let l40 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                      let len41 = l40;
                                      let bytes41 = _rt::Vec::from_raw_parts(l39.cast(), len41, len41);

                                      Route{
                                        methods: result38,
                                        path: _rt::string_lift(bytes41),
                                      }
                                    };
                                    result42.push(e42);
                                  }
                                  _rt::cabi_dealloc(base42, len42 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                                  let l43 = i32::from(*base.add(6*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                  WebhokEndpoint{
                                    name: _rt::string_lift(bytes27),
                                    location_oci: _rt::string_lift(bytes30),
                                    routes: result42,
                                    env_vars: match l43 {
                                      0 => None,
                                      1 => {
                                        let e = {
                                          let l44 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                          let l45 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                          let base49 = l44;
                                          let len49 = l45;
                                          let mut result49 = _rt::Vec::with_capacity(len49);
                                          for i in 0..len49 {
                                            let base = base49.add(i * (2*::core::mem::size_of::<*const u8>()));
                                            let e49 = {
                                              let l46 = *base.add(0).cast::<*mut u8>();
                                              let l47 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                              let len48 = l47;
                                              let bytes48 = _rt::Vec::from_raw_parts(l46.cast(), len48, len48);

                                              _rt::string_lift(bytes48)
                                            };
                                            result49.push(e49);
                                          }
                                          _rt::cabi_dealloc(base49, len49 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                                          result49
                                        };
                                        Some(e)
                                      }
                                      _ => _rt::invalid_enum_discriminant(),
                                    },
                                  }
                                };
                                result50.push(e50);
                              }
                              _rt::cabi_dealloc(base50, len50 * (9*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

                              result50
                            };
                            Some(e)
                          }
                          _ => _rt::invalid_enum_discriminant(),
                        },
                      })
                    };
                    let ptr52 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result51 {
                      Ok(e) => { {
                        *ptr52.add(0).cast::<u8>() = (0i32) as u8;
                        let vec55 = e;
                        let len55 = vec55.len();
                        let layout55 = _rt::alloc::Layout::from_size_align(vec55.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                        let (result55, _cleanup55) = wit_bindgen::rt::Cleanup::new(layout55);if let Some(cleanup) = _cleanup55 { cleanup.forget(); }
                        for (i, e) in vec55.into_iter().enumerate() {
                          let base = result55.add(i * (3*::core::mem::size_of::<*const u8>()));
                          {
                            let SecretKey{ name:name53, present:present53, } = e;
                            let vec54 = (name53.into_bytes()).into_boxed_slice();
                            let ptr54 = vec54.as_ptr().cast::<u8>();
                            let len54 = vec54.len();
                            ::core::mem::forget(vec54);
                            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len54;
                            *base.add(0).cast::<*mut u8>() = ptr54.cast_mut();
                            *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match present53 { true => 1, false => 0 }) as u8;
                          }
                        }
                        *ptr52.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len55;
                        *ptr52.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result55;
                      } },
                      Err(e) => { {
                        *ptr52.add(0).cast::<u8>() = (1i32) as u8;
                        match e {
                          AppCreateError::Conflict=> {
                            {
                              *ptr52.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                            }
                          }
                          AppCreateError::VolumeCreateError(e) => {
                            *ptr52.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                            let vec56 = (e.into_bytes()).into_boxed_slice();
                            let ptr56 = vec56.as_ptr().cast::<u8>();
                            let len56 = vec56.len();
                            ::core::mem::forget(vec56);
                            *ptr52.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len56;
                            *ptr52.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr56.cast_mut();
                          },
                          AppCreateError::TempVmError(e) => {
                            *ptr52.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                            let vec57 = (e.into_bytes()).into_boxed_slice();
                            let ptr57 = vec57.as_ptr().cast::<u8>();
                            let len57 = vec57.len();
                            ::core::mem::forget(vec57);
                            *ptr52.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len57;
                            *ptr52.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr57.cast_mut();
                          },
                          AppCreateError::VolumeWriteError(e) => {
                            *ptr52.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                            let vec58 = (e.into_bytes()).into_boxed_slice();
                            let ptr58 = vec58.as_ptr().cast::<u8>();
                            let len58 = vec58.len();
                            ::core::mem::forget(vec58);
                            *ptr52.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len58;
                            *ptr52.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr58.cast_mut();
                          },
                          AppCreateError::VerifyError(e) => {
                            *ptr52.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32) as u8;
                            let vec59 = (e.into_bytes()).into_boxed_slice();
                            let ptr59 = vec59.as_ptr().cast::<u8>();
                            let len59 = vec59.len();
                            ::core::mem::forget(vec59);
                            *ptr52.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len59;
                            *ptr52.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr59.cast_mut();
                          },
                        }
                      } },
                    };ptr52
                  } }
                  #[doc(hidden)]
                  #[allow(non_snake_case)]
                  pub unsafe fn __post_return_app_create<T: Guest>(arg0: *mut u8,) { unsafe {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                      0 => {
                        let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        let base5 = l1;
                        let len5 = l2;
                        for i in 0..len5 {
                          let base = base5.add(i * (3*::core::mem::size_of::<*const u8>()));
                          {
                            let l3 = *base.add(0).cast::<*mut u8>();
                            let l4 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                          }
                        }
                        _rt::cabi_dealloc(base5, len5 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                      },
                      _ => {
                        let l6 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                        match l6 {
                          0 => (),
                          1 => {
                            let l7 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l8 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                          },
                          2 => {
                            let l9 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l10 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l9, l10, 1);
                          },
                          3 => {
                            let l11 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l12 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l11, l12, 1);
                          },
                          _ => {
                            let l13 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                            let l14 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                            _rt::cabi_dealloc(l13, l14, 1);
                          },
                        }
                      },
                    }
                  } }
                  #[doc(hidden)]
                  #[allow(non_snake_case, unused_unsafe)]
                  pub unsafe fn _export_secret_list_keys_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                  _rt::run_ctors_once();let result1 = {
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    T::secret_list_keys(_rt::string_lift(bytes0))
                  };
                  let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                  let vec5 = result1;
                  let len5 = vec5.len();
                  let layout5 = _rt::alloc::Layout::from_size_align(vec5.len() * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                  let (result5, _cleanup5) = wit_bindgen::rt::Cleanup::new(layout5);if let Some(cleanup) = _cleanup5 { cleanup.forget(); }
                  for (i, e) in vec5.into_iter().enumerate() {
                    let base = result5.add(i * (3*::core::mem::size_of::<*const u8>()));
                    {
                      let SecretKey{ name:name3, present:present3, } = e;
                      let vec4 = (name3.into_bytes()).into_boxed_slice();
                      let ptr4 = vec4.as_ptr().cast::<u8>();
                      let len4 = vec4.len();
                      ::core::mem::forget(vec4);
                      *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                      *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                      *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match present3 { true => 1, false => 0 }) as u8;
                    }
                  }
                  *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                  *ptr2.add(0).cast::<*mut u8>() = result5;
                  ptr2
                } }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_secret_list_keys<T: Guest>(arg0: *mut u8,) { unsafe {
                  let l0 = *arg0.add(0).cast::<*mut u8>();
                  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base4 = l0;
                  let len4 = l1;
                  for i in 0..len4 {
                    let base = base4.add(i * (3*::core::mem::size_of::<*const u8>()));
                    {
                      let l2 = *base.add(0).cast::<*mut u8>();
                      let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      _rt::cabi_dealloc(l2, l3, 1);
                    }
                  }
                  _rt::cabi_dealloc(base4, len4 * (3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                } }
                #[doc(hidden)]
                #[allow(non_snake_case, unused_unsafe)]
                pub unsafe fn _export_serve_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                _rt::run_ctors_once();let result1 = {
                  let len0 = arg1;
                  let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                  T::serve(_rt::string_lift(bytes0))
                };
                let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                match result1 {
                  Ok(_) => { {
                    *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                  } },
                  Err(e) => { {
                    *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                    match e {
                      ServeError::VmStartError(e) => {
                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                        let vec3 = (e.into_bytes()).into_boxed_slice();
                        let ptr3 = vec3.as_ptr().cast::<u8>();
                        let len3 = vec3.len();
                        ::core::mem::forget(vec3);
                        *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                        *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3.cast_mut();
                      },
                      ServeError::HealthcheckError(e) => {
                        *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                        let vec4 = (e.into_bytes()).into_boxed_slice();
                        let ptr4 = vec4.as_ptr().cast::<u8>();
                        let len4 = vec4.len();
                        ::core::mem::forget(vec4);
                        *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                        *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
                      },
                    }
                  } },
                };ptr2
              } }
              #[doc(hidden)]
              #[allow(non_snake_case)]
              pub unsafe fn __post_return_serve<T: Guest>(arg0: *mut u8,) { unsafe {
                let l0 = i32::from(*arg0.add(0).cast::<u8>());
                match l0 {
                  0 => (),
                  _ => {
                    let l1 = i32::from(*arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                    match l1 {
                      0 => {
                        let l2 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l3 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l2, l3, 1);
                      },
                      _ => {
                        let l4 = *arg0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                        let l5 = *arg0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                        _rt::cabi_dealloc(l4, l5, 1);
                      },
                    }
                  },
                }
              } }
              #[doc(hidden)]
              #[allow(non_snake_case, unused_unsafe)]
              pub unsafe fn _export_app_delete_cabi<T: Guest>(arg0: *mut u8,arg1: usize,) { unsafe {#[cfg(target_arch="wasm32")]
              _rt::run_ctors_once();{
                let len0 = arg1;
                let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                T::app_delete(_rt::string_lift(bytes0))
              };
            } }
            pub trait Guest {
              /// Create a fly app (if not exists).
              /// Prepare volume, if not exists. If it exists with
              /// Launch a temporary VM. It will be cleaned up at the end of execution.
              /// Store the config file and download WASM components + AOT generated code (`obelisk server verify --ignore-missing-env-vars`).
              /// Return list of secret keys the config requires.
              #[allow(async_fn_in_trait)]
              fn app_create(app_name: _rt::String,volume_config: VolumeConfig,config: ObeliskConfig,) -> Result<_rt::Vec::<SecretKey>,AppCreateError>;
              /// Read the app's configuration and return its secret keys.
              #[allow(async_fn_in_trait)]
              fn secret_list_keys(app_name: _rt::String,) -> _rt::Vec::<SecretKey>;
              /// Serve Obelisk app on a VM.
              #[allow(async_fn_in_trait)]
              fn serve(app_name: _rt::String,) -> Result<(),ServeError>;
              /// Delete application with all its associated resources.
              #[allow(async_fn_in_trait)]
              fn app_delete(name: _rt::String,) -> ();
            }
            #[doc(hidden)]

            macro_rules! __export_obelisk_flyio_workflow_workflow_1_0_0_beta_cabi{
              ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

                #[unsafe(export_name = "obelisk-flyio:workflow/workflow@1.0.0-beta#app-create")]
                unsafe extern "C" fn export_app_create(arg0: *mut u8,arg1: usize,arg2: i32,arg3: *mut u8,arg4: usize,arg5: i32,arg6: *mut u8,arg7: usize,arg8: i32,arg9: *mut u8,arg10: usize,arg11: i32,arg12: *mut u8,arg13: usize,) -> *mut u8 {
                  unsafe { $($path_to_types)*::_export_app_create_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13) }
                }
                #[unsafe(export_name = "cabi_post_obelisk-flyio:workflow/workflow@1.0.0-beta#app-create")]
                unsafe extern "C" fn _post_return_app_create(arg0: *mut u8,) {
                  unsafe { $($path_to_types)*::__post_return_app_create::<$ty>(arg0) }
                }
                #[unsafe(export_name = "obelisk-flyio:workflow/workflow@1.0.0-beta#secret-list-keys")]
                unsafe extern "C" fn export_secret_list_keys(arg0: *mut u8,arg1: usize,) -> *mut u8 {
                  unsafe { $($path_to_types)*::_export_secret_list_keys_cabi::<$ty>(arg0, arg1) }
                }
                #[unsafe(export_name = "cabi_post_obelisk-flyio:workflow/workflow@1.0.0-beta#secret-list-keys")]
                unsafe extern "C" fn _post_return_secret_list_keys(arg0: *mut u8,) {
                  unsafe { $($path_to_types)*::__post_return_secret_list_keys::<$ty>(arg0) }
                }
                #[unsafe(export_name = "obelisk-flyio:workflow/workflow@1.0.0-beta#serve")]
                unsafe extern "C" fn export_serve(arg0: *mut u8,arg1: usize,) -> *mut u8 {
                  unsafe { $($path_to_types)*::_export_serve_cabi::<$ty>(arg0, arg1) }
                }
                #[unsafe(export_name = "cabi_post_obelisk-flyio:workflow/workflow@1.0.0-beta#serve")]
                unsafe extern "C" fn _post_return_serve(arg0: *mut u8,) {
                  unsafe { $($path_to_types)*::__post_return_serve::<$ty>(arg0) }
                }
                #[unsafe(export_name = "obelisk-flyio:workflow/workflow@1.0.0-beta#app-delete")]
                unsafe extern "C" fn export_app_delete(arg0: *mut u8,arg1: usize,) {
                  unsafe { $($path_to_types)*::_export_app_delete_cabi::<$ty>(arg0, arg1) }
                }
              };);
            }
            #[doc(hidden)]
            pub(crate) use __export_obelisk_flyio_workflow_workflow_1_0_0_beta_cabi;

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct _RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
            static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);

          }

        }
      }
    }
    mod _rt {
      #![allow(dead_code, clippy::all)]
      pub use alloc_crate::string::String;
      pub use alloc_crate::vec::Vec;
      pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
          String::from_utf8(bytes).unwrap()
        } else {
          unsafe { String::from_utf8_unchecked(bytes) }
        }
      }
      pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
          match val {
            0 => false,
            1 => true,
            _ => panic!("invalid bool discriminant"),
          }
        } else {
          val != 0
        }
      }
      pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
          panic!("invalid enum discriminant")
        } else {
          unsafe { core::hint::unreachable_unchecked() }
        }
      }
      pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
          return;
        }
        unsafe {
          let layout = alloc::Layout::from_size_align_unchecked(size, align);
          alloc::dealloc(ptr, layout);
        }
      }
      
      pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
      }

      pub trait AsI32 {
        fn as_i32(self) -> i32;
      }

      impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
          (*self).as_i32()
        }
      }
      
      impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
          self as i32
        }
      }
      
      pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
      }

      pub trait AsI64 {
        fn as_i64(self) -> i64;
      }

      impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
          (*self).as_i64()
        }
      }
      
      impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
          self as i64
        }
      }
      
      impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
          self as i64
        }
      }
      pub use alloc_crate::alloc;

      #[cfg(target_arch = "wasm32")]
      pub fn run_ctors_once() {
        wit_bindgen::rt::run_ctors_once();
      }
      extern crate alloc as alloc_crate;
    }

    /// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
    /// the root implementation of all generated traits.
    ///
    /// For more information see the documentation of `wit_bindgen::generate!`.
    ///
    /// ```rust
    /// # macro_rules! export{ ($($t:tt)*) => (); }
    /// # trait Guest {}
    /// struct MyType;
    ///
    /// impl Guest for MyType {
    ///     // ...
    /// }
    ///
    /// export!(MyType);
    /// ```
    #[allow(unused_macros)]
    #[doc(hidden)]

    macro_rules! __export_any_impl {
      ($ty:ident) => (self::export!($ty with_types_in self););
      ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
      $($path_to_types_root)*::exports::obelisk_flyio::workflow::workflow::__export_obelisk_flyio_workflow_workflow_1_0_0_beta_cabi!($ty with_types_in $($path_to_types_root)*::exports::obelisk_flyio::workflow::workflow);
      )
    }
    #[doc(inline)]
    pub(crate) use __export_any_impl as export;

    #[cfg(target_arch = "wasm32")]
    #[unsafe(link_section = "component-type:wit-bindgen:0.45.1:any:any:any:encoded world")]
    #[doc(hidden)]
    #[allow(clippy::octal_escapes)]
    pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3219] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x99\x18\x01A\x02\x01\
A\x0c\x01B\x02\x01m#\x03ams\x03arn\x03atl\x03bog\x03bom\x03bos\x03cdg\x03den\x03\
dfw\x03ewr\x03eze\x03fra\x03gdl\x03gig\x03gru\x03hkg\x03iad\x03jnb\x03lax\x03lhr\
\x03mad\x03mia\x03nrt\x03ord\x03otp\x03phx\x03qro\x03scl\x03sea\x03sin\x03sjc\x03\
syd\x03waw\x03yul\x03yyz\x04\0\x06region\x03\0\0\x03\02obelisk-flyio:activity-fl\
y-http/regions@1.0.0-beta\x05\0\x02\x03\0\0\x06region\x01B\x18\x02\x03\x02\x01\x01\
\x04\0\x06region\x03\0\0\x01s\x04\0\x09volume-id\x03\0\x02\x01ks\x01r\x0f\x02ids\
\x04names\x05states\x06region\x01\x07size-gby\x09encrypted\x7f\x13attached-machi\
ne-id\x04\x0bhost-statuss\x0acreated-ats\x06blocksy\x0ablock-sizey\x0bblocks-fre\
ey\x0cblocks-availy\x0abytes-usedy\x0bbytes-totaly\x04\0\x06volume\x03\0\x05\x01\
k\x7f\x01r\x04\x04names\x07size-gby\x06region\x01\x13require-unique-zone\x07\x04\
\0\x15volume-create-request\x03\0\x08\x01p\x06\x01j\x01\x0a\x01s\x01@\x01\x08app\
-names\0\x0b\x04\0\x04list\x01\x0c\x01j\x01\x06\x01s\x01@\x02\x08app-names\x07re\
quest\x09\0\x0d\x04\0\x06create\x01\x0e\x01@\x02\x08app-names\x09volume-id\x03\0\
\x0d\x04\0\x03get\x01\x0f\x01j\0\x01s\x01@\x03\x08app-names\x09volume-id\x03\x0b\
new-size-gby\0\x10\x04\0\x06extend\x01\x11\x01@\x02\x08app-names\x09volume-id\x03\
\0\x10\x04\0\x06delete\x01\x12\x03\02obelisk-flyio:activity-fly-http/volumes@1.0\
.0-beta\x05\x02\x02\x03\0\x01\x09volume-id\x01BP\x02\x03\x02\x01\x01\x04\0\x06re\
gion\x03\0\0\x02\x03\x02\x01\x03\x04\0\x09volume-id\x03\0\x02\x01s\x04\0\x0amach\
ine-id\x03\0\x04\x01m\x0b\x07created\x08starting\x07started\x08stopping\x07stopp\
ed\x0asuspending\x09suspended\x09replacing\x08replaced\x0adestroying\x09destroye\
d\x04\0\x0dmachine-state\x03\0\x06\x01m\x03\x02ok\x07unknown\x0bunreachable\x04\0\
\x0bhost-status\x03\0\x08\x01r\x02\x06volume\x03\x04paths\x04\0\x05mount\x03\0\x0a\
\x01m\x02\x06shared\x0bperformance\x04\0\x08cpu-kind\x03\0\x0c\x01k\x0d\x01kw\x01\
ps\x01k\x10\x01r\x04\x08cpu-kind\x0e\x04cpus\x0f\x09memory-mb\x0f\x0bkernel-args\
\x11\x04\0\x0cguest-config\x03\0\x12\x01m\x03\x02no\x06always\x0aon-failure\x04\0\
\x0erestart-policy\x03\0\x14\x01ky\x01r\x02\x0bmax-retries\x16\x06policy\x15\x04\
\0\x0fmachine-restart\x03\0\x17\x01k\x7f\x01r\x06\x03cmd\x11\x0aentrypoint\x11\x04\
exec\x11\x0bkernel-args\x11\x0cswap-size-mb\x0f\x03tty\x19\x04\0\x0binit-config\x03\
\0\x1a\x01ks\x01r\x02\x06signal\x1c\x07timeout\x0f\x04\0\x0bstop-config\x03\0\x1d\
\x01kz\x01r\x04\x09exit-code\x1f\x0bexit-signal\x1f\x06stderr\x1c\x06stdout\x1c\x04\
\0\x0dexec-response\x03\0\x20\x01m\x02\x03tcp\x03udp\x04\0\x10service-protocol\x03\
\0\"\x01m\x03\x04http\x03tls\x02pg\x04\0\x0cport-handler\x03\0$\x01p%\x01r\x02\x04\
port{\x08handlers&\x04\0\x0bport-config\x03\0'\x01p(\x01r\x03\x0dinternal-port{\x08\
protocol#\x05ports)\x04\0\x0eservice-config\x03\0*\x01k\x13\x01k\x1b\x01o\x02ss\x01\
p.\x01k/\x01k\x18\x01k\x1e\x01p\x0b\x01k3\x01p+\x01k5\x01r\x09\x05images\x05gues\
t,\x0cauto-destroy\x19\x04init-\x03env0\x07restart1\x0bstop-config2\x06mounts4\x08\
services6\x04\0\x0emachine-config\x03\07\x01r\x09\x06config8\x0acreated-ats\x0au\
pdated-ats\x02ids\x0binstance-ids\x04names\x05states\x06region\x01\x0bhost-statu\
s\x09\x04\0\x07machine\x03\09\x01p:\x01j\x01;\x01s\x01@\x01\x08app-names\0<\x04\0\
\x04list\x01=\x01k\x01\x01j\x01s\x01s\x01@\x04\x08app-names\x0cmachine-names\x0e\
machine-config8\x06region>\0?\x04\0\x06create\x01@\x01j\0\x01s\x01@\x04\x08app-n\
ames\x0amachine-id\x05\x0emachine-config8\x06region>\0\xc1\0\x04\0\x06update\x01\
B\x01@\x02\x08app-names\x0amachine-id\x05\0\xc1\0\x04\0\x07suspend\x01C\x04\0\x04\
stop\x01C\x04\0\x05start\x01C\x04\0\x07restart\x01C\x01@\x03\x08app-names\x0amac\
hine-id\x05\x05force\x7f\0\xc1\0\x04\0\x06delete\x01D\x01j\x01!\x01s\x01@\x03\x08\
app-names\x0amachine-id\x05\x07command\x10\0\xc5\0\x04\0\x04exec\x01F\x03\03obel\
isk-flyio:activity-fly-http/machines@1.0.0-beta\x05\x04\x02\x03\0\x02\x0amachine\
-id\x02\x03\0\x02\x09volume-id\x01B.\x02\x03\x02\x01\x05\x04\0\x0amachine-id\x03\
\0\0\x02\x03\x02\x01\x06\x04\0\x09volume-id\x03\0\x02\x01s\x04\0\x07env-var\x03\0\
\x04\x01r\x02\x0asize-in-gb{\x04names\x04\0\x0dvolume-config\x03\0\x06\x01p\x05\x01\
k\x08\x01ky\x01r\x04\x04names\x0clocation-ocis\x08env-vars\x09\x13lock-expiry-se\
conds\x0a\x04\0\x0dactivity-wasm\x03\0\x0b\x01r\x02\x04names\x0clocation-ocis\x04\
\0\x08workflow\x03\0\x0d\x01ps\x01r\x02\x07methods\x0f\x04paths\x04\0\x05route\x03\
\0\x10\x01p\x11\x01r\x04\x04names\x0clocation-ocis\x06routes\x12\x08env-vars\x09\
\x04\0\x0fwebhok-endpoint\x03\0\x13\x01p\x0c\x01k\x15\x01p\x0e\x01k\x17\x01p\x14\
\x01k\x19\x01r\x03\x12activity-wasm-list\x16\x0dworkflow-list\x18\x15webhook-end\
point-list\x1a\x04\0\x0eobelisk-config\x03\0\x1b\x01r\x02\x04names\x07present\x7f\
\x04\0\x0asecret-key\x03\0\x1d\x01q\x05\x08conflict\0\0\x13volume-create-error\x01\
s\0\x0dtemp-vm-error\x01s\0\x12volume-write-error\x01s\0\x0cverify-error\x01s\0\x04\
\0\x10app-create-error\x03\0\x1f\x01q\x02\x0evm-start-error\x01s\0\x11healthchec\
k-error\x01s\0\x04\0\x0bserve-error\x03\0!\x01p\x1e\x01j\x01#\x01\x20\x01@\x03\x08\
app-names\x0dvolume-config\x07\x06config\x1c\0$\x04\0\x0aapp-create\x01%\x01@\x01\
\x08app-names\0#\x04\0\x10secret-list-keys\x01&\x01j\0\x01\"\x01@\x01\x08app-nam\
es\0'\x04\0\x05serve\x01(\x01@\x01\x04names\x01\0\x04\0\x0aapp-delete\x01)\x04\0\
*obelisk-flyio:workflow/workflow@1.0.0-beta\x05\x07\x04\0\x0bany:any/any\x04\0\x0b\
\x09\x01\0\x03any\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-compone\
nt\x070.238.0\x10wit-bindgen-rust\x060.45.1";

    #[inline(never)]
    #[doc(hidden)]
    pub fn __link_custom_section_describing_imports() {
      wit_bindgen::rt::maybe_link_cabi_realloc();
    }
    
